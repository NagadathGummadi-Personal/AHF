// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by scripts/generate_flutter.py

// ignore_for_file: constant_identifier_names

enum ToolType {
  function('function'),
  http('http'),
  db('db'),
  ;

  final String value;
  const ToolType(this.value);

  static ToolType fromString(String? value) {
    if (value == null) return values.first;
    return values.firstWhere(
      (e) => e.value == value,
      orElse: () => values.first,
    );
  }

  String get label {
    switch (this) {
      case ToolType.function:
        return 'Function (Python)';
      case ToolType.http:
        return 'HTTP (REST API)';
      case ToolType.db:
        return 'Database (SQL/NoSQL)';
    }
  }
}

enum ToolReturnType {
  json('json'),
  toon('toon'),
  text('text'),
  ;

  final String value;
  const ToolReturnType(this.value);

  static ToolReturnType fromString(String? value) {
    if (value == null) return values.first;
    return values.firstWhere(
      (e) => e.value == value,
      orElse: () => values.first,
    );
  }

  String get label {
    switch (this) {
      case ToolReturnType.json:
        return 'JSON';
      case ToolReturnType.toon:
        return 'TOON';
      case ToolReturnType.text:
        return 'Text';
    }
  }
}

enum ToolReturnTarget {
  human('human'),
  llm('llm'),
  agent('agent'),
  step('step'),
  ;

  final String value;
  const ToolReturnTarget(this.value);

  static ToolReturnTarget fromString(String? value) {
    if (value == null) return values.first;
    return values.firstWhere(
      (e) => e.value == value,
      orElse: () => values.first,
    );
  }

  String get label {
    switch (this) {
      case ToolReturnTarget.human:
        return 'Human (direct to user)';
      case ToolReturnTarget.llm:
        return 'LLM (continue conversation)';
      case ToolReturnTarget.agent:
        return 'Agent (for agent processing)';
      case ToolReturnTarget.step:
        return 'Step (workflow step output)';
    }
  }
}

enum ParameterType {
  string('string'),
  number('number'),
  integer('integer'),
  boolean('boolean'),
  array('array'),
  object('object'),
  ;

  final String value;
  const ParameterType(this.value);

  static ParameterType fromString(String? value) {
    if (value == null) return values.first;
    return values.firstWhere(
      (e) => e.value == value,
      orElse: () => values.first,
    );
  }

  String get label {
    switch (this) {
      case ParameterType.string:
        return 'String';
      case ParameterType.number:
        return 'Number';
      case ParameterType.integer:
        return 'Integer';
      case ParameterType.boolean:
        return 'Boolean';
      case ParameterType.array:
        return 'Array';
      case ParameterType.object:
        return 'Object';
    }
  }
}

enum SpeechMode {
  auto('auto'),
  random('random'),
  constant('constant'),
  ;

  final String value;
  const SpeechMode(this.value);

  static SpeechMode fromString(String? value) {
    if (value == null) return values.first;
    return values.firstWhere(
      (e) => e.value == value,
      orElse: () => values.first,
    );
  }

  String get label {
    switch (this) {
      case SpeechMode.auto:
        return 'Auto (LLM generates)';
      case SpeechMode.random:
        return 'Random (from list)';
      case SpeechMode.constant:
        return 'Constant (fixed message)';
    }
  }
}

enum ExecutionMode {
  sequential('sequential'),
  parallel('parallel'),
  ;

  final String value;
  const ExecutionMode(this.value);

  static ExecutionMode fromString(String? value) {
    if (value == null) return values.first;
    return values.firstWhere(
      (e) => e.value == value,
      orElse: () => values.first,
    );
  }

  String get label {
    switch (this) {
      case ExecutionMode.sequential:
        return 'Sequential (speech then execute)';
      case ExecutionMode.parallel:
        return 'Parallel (speech and execute together)';
    }
  }
}

enum VariableAssignmentOperator {
  set('set'),
  setIfExists('set_if_exists'),
  setIfTruthy('set_if_truthy'),
  append('append'),
  increment('increment'),
  transform('transform'),
  ;

  final String value;
  const VariableAssignmentOperator(this.value);

  static VariableAssignmentOperator fromString(String? value) {
    if (value == null) return values.first;
    return values.firstWhere(
      (e) => e.value == value,
      orElse: () => values.first,
    );
  }

  String get label {
    switch (this) {
      case VariableAssignmentOperator.set:
        return 'Set (always)';
      case VariableAssignmentOperator.setIfExists:
        return 'Set if Exists';
      case VariableAssignmentOperator.setIfTruthy:
        return 'Set if Truthy';
      case VariableAssignmentOperator.append:
        return 'Append to List';
      case VariableAssignmentOperator.increment:
        return 'Increment Number';
      case VariableAssignmentOperator.transform:
        return 'Transform with Function';
    }
  }
}

enum SpeechContextScope {
  fullContext('full_context'),
  toolOnly('tool_only'),
  lastMessage('last_message'),
  custom('custom'),
  ;

  final String value;
  const SpeechContextScope(this.value);

  static SpeechContextScope fromString(String? value) {
    if (value == null) return values.first;
    return values.firstWhere(
      (e) => e.value == value,
      orElse: () => values.first,
    );
  }

  String get label {
    switch (this) {
      case SpeechContextScope.fullContext:
        return 'Full Context';
      case SpeechContextScope.toolOnly:
        return 'Tool Only';
      case SpeechContextScope.lastMessage:
        return 'Last Message';
      case SpeechContextScope.custom:
        return 'Custom Instruction';
    }
  }
}

enum TransformExecutionMode {
  sync('sync'),
  async('async'),
  await('await'),
  ;

  final String value;
  const TransformExecutionMode(this.value);

  static TransformExecutionMode fromString(String? value) {
    if (value == null) return values.first;
    return values.firstWhere(
      (e) => e.value == value,
      orElse: () => values.first,
    );
  }

  String get label {
    switch (this) {
      case TransformExecutionMode.sync:
        return 'Sync (block)';
      case TransformExecutionMode.async:
        return 'Async (fire-and-forget)';
      case TransformExecutionMode.await:
        return 'Await (async but wait)';
    }
  }
}

enum CircuitBreakerState {
  closed('closed'),
  open('open'),
  halfOpen('half_open'),
  ;

  final String value;
  const CircuitBreakerState(this.value);

  static CircuitBreakerState fromString(String? value) {
    if (value == null) return values.first;
    return values.firstWhere(
      (e) => e.value == value,
      orElse: () => values.first,
    );
  }

  String get label {
    switch (this) {
      case CircuitBreakerState.closed:
        return 'Closed (normal)';
      case CircuitBreakerState.open:
        return 'Open (failing fast)';
      case CircuitBreakerState.halfOpen:
        return 'Half Open (testing)';
    }
  }
}
