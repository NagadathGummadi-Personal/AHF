// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by scripts/generate_flutter.py

// ignore_for_file: unnecessary_this

class RetryConfig {
  /// Enable Retries
  /// Automatically retry on transient failures
  final bool? enabled;
  /// Max Retry Attempts
  /// Maximum number of retry attempts before giving up
  final int? maxAttempts;
  /// Base Delay
  /// Initial delay between retries (seconds)
  final double? baseDelayS;
  /// Max Delay
  /// Maximum delay between retries with exponential backoff
  final double? maxDelayS;
  /// Jitter
  /// Random jitter added to delay to prevent thundering herd
  final double? jitterS;

  const RetryConfig({
    this.enabled,
    this.maxAttempts,
    this.baseDelayS,
    this.maxDelayS,
    this.jitterS,
  });

  factory RetryConfig.fromJson(Map<String, dynamic> json) {
    return RetryConfig(
      enabled: json['enabled'] as bool?,
      maxAttempts: json['max_attempts'] as int?,
      baseDelayS: (json['base_delay_s'] as num?)?.toDouble(),
      maxDelayS: (json['max_delay_s'] as num?)?.toDouble(),
      jitterS: (json['jitter_s'] as num?)?.toDouble(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      if (enabled != null) 'enabled': enabled,
      if (maxAttempts != null) 'max_attempts': maxAttempts,
      if (baseDelayS != null) 'base_delay_s': baseDelayS,
      if (maxDelayS != null) 'max_delay_s': maxDelayS,
      if (jitterS != null) 'jitter_s': jitterS,
    };
  }

  RetryConfig copyWith({
    bool? enabled,
    int? maxAttempts,
    double? baseDelayS,
    double? maxDelayS,
    double? jitterS,
  }}) {
    return RetryConfig(
      enabled: enabled ?? this.enabled,
      maxAttempts: maxAttempts ?? this.maxAttempts,
      baseDelayS: baseDelayS ?? this.baseDelayS,
      maxDelayS: maxDelayS ?? this.maxDelayS,
      jitterS: jitterS ?? this.jitterS,
    );
  }

  factory RetryConfig.empty() {
    return const RetryConfig();
  }
}

class CircuitBreakerConfig {
  /// Enable Circuit Breaker
  /// Fail fast when service is unhealthy to prevent cascading failures
  final bool? enabled;
  /// Failure Threshold
  /// Consecutive failures before opening the circuit
  final int? failureThreshold;
  /// Recovery Timeout
  /// Seconds to wait before attempting recovery (OPEN â†’ HALF_OPEN)
  final int? recoveryTimeoutS;
  /// Half-Open Max Calls
  /// Number of test calls allowed in HALF_OPEN state
  final int? halfOpenMaxCalls;
  /// Error Codes to Trip
  /// Error codes that should trip the circuit breaker
  final List<String>? errorCodesToTrip;

  const CircuitBreakerConfig({
    this.enabled,
    this.failureThreshold,
    this.recoveryTimeoutS,
    this.halfOpenMaxCalls,
    this.errorCodesToTrip,
  });

  factory CircuitBreakerConfig.fromJson(Map<String, dynamic> json) {
    return CircuitBreakerConfig(
      enabled: json['enabled'] as bool?,
      failureThreshold: json['failure_threshold'] as int?,
      recoveryTimeoutS: json['recovery_timeout_s'] as int?,
      halfOpenMaxCalls: json['half_open_max_calls'] as int?,
      errorCodesToTrip: (json['error_codes_to_trip'] as List?)?.cast<String>(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      if (enabled != null) 'enabled': enabled,
      if (failureThreshold != null) 'failure_threshold': failureThreshold,
      if (recoveryTimeoutS != null) 'recovery_timeout_s': recoveryTimeoutS,
      if (halfOpenMaxCalls != null) 'half_open_max_calls': halfOpenMaxCalls,
      if (errorCodesToTrip != null) 'error_codes_to_trip': errorCodesToTrip,
    };
  }

  CircuitBreakerConfig copyWith({
    bool? enabled,
    int? failureThreshold,
    int? recoveryTimeoutS,
    int? halfOpenMaxCalls,
    List<String>? errorCodesToTrip,
  }}) {
    return CircuitBreakerConfig(
      enabled: enabled ?? this.enabled,
      failureThreshold: failureThreshold ?? this.failureThreshold,
      recoveryTimeoutS: recoveryTimeoutS ?? this.recoveryTimeoutS,
      halfOpenMaxCalls: halfOpenMaxCalls ?? this.halfOpenMaxCalls,
      errorCodesToTrip: errorCodesToTrip ?? this.errorCodesToTrip,
    );
  }

  factory CircuitBreakerConfig.empty() {
    return const CircuitBreakerConfig();
  }
}

class IdempotencyConfig {
  /// Enable Idempotency
  /// Cache and guard against repeated executions using key fields
  final bool? enabled;
  /// Key Fields
  /// Fields to use for idempotency key (empty = all args)
  final List<String>? keyFields;
  /// TTL (seconds)
  /// Time-to-live for cached results
  final int? ttlS;
  /// Persist Result
  /// Store result for reuse on duplicate calls
  final bool? persistResult;
  /// Bypass on Missing Key
  /// Skip idempotency check if key fields are missing
  final bool? bypassOnMissingKey;

  const IdempotencyConfig({
    this.enabled,
    this.keyFields,
    this.ttlS,
    this.persistResult,
    this.bypassOnMissingKey,
  });

  factory IdempotencyConfig.fromJson(Map<String, dynamic> json) {
    return IdempotencyConfig(
      enabled: json['enabled'] as bool?,
      keyFields: (json['key_fields'] as List?)?.cast<String>(),
      ttlS: json['ttl_s'] as int?,
      persistResult: json['persist_result'] as bool?,
      bypassOnMissingKey: json['bypass_on_missing_key'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      if (enabled != null) 'enabled': enabled,
      if (keyFields != null) 'key_fields': keyFields,
      if (ttlS != null) 'ttl_s': ttlS,
      if (persistResult != null) 'persist_result': persistResult,
      if (bypassOnMissingKey != null) 'bypass_on_missing_key': bypassOnMissingKey,
    };
  }

  IdempotencyConfig copyWith({
    bool? enabled,
    List<String>? keyFields,
    int? ttlS,
    bool? persistResult,
    bool? bypassOnMissingKey,
  }}) {
    return IdempotencyConfig(
      enabled: enabled ?? this.enabled,
      keyFields: keyFields ?? this.keyFields,
      ttlS: ttlS ?? this.ttlS,
      persistResult: persistResult ?? this.persistResult,
      bypassOnMissingKey: bypassOnMissingKey ?? this.bypassOnMissingKey,
    );
  }

  factory IdempotencyConfig.empty() {
    return const IdempotencyConfig();
  }
}

class InterruptionConfig {
  /// Disable Interruption
  /// If enabled, tool execution cannot be interrupted by user input
  final bool? disabled;

  const InterruptionConfig({
    this.disabled,
  });

  factory InterruptionConfig.fromJson(Map<String, dynamic> json) {
    return InterruptionConfig(
      disabled: json['disabled'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      if (disabled != null) 'disabled': disabled,
    };
  }

  InterruptionConfig copyWith({
    bool? disabled,
  }}) {
    return InterruptionConfig(
      disabled: disabled ?? this.disabled,
    );
  }

  factory InterruptionConfig.empty() {
    return const InterruptionConfig();
  }
}

class PreToolSpeechConfig {
  /// Enable Pre-Tool Speech
  /// Whether to speak/announce before tool execution
  final bool? enabled;
  /// Speech Mode
  /// How to generate the pre-tool speech
  final SpeechMode? mode;
  /// Constant Message
  /// Fixed message to use when mode is CONSTANT
  final String? constantMessage;
  /// Random Messages
  /// List of messages to randomly select from
  final List<String>? randomMessages;
  /// Context Scope
  /// What context the LLM uses when generating speech
  final SpeechContextScope? contextScope;
  /// Custom LLM Instruction
  /// Custom instruction for LLM (required when context_scope=CUSTOM)
  final String? llmInstruction;
  /// Include Tool Parameters
  /// Include tool parameters in context for speech generation
  final bool? includeToolParams;
  /// Include User Intent
  /// Include detected user intent in context
  final bool? includeUserIntent;
  /// Max Tokens
  /// Maximum tokens for generated speech
  final int? maxTokens;
  /// Temperature
  /// LLM temperature (higher = more creative)
  final double? temperature;
  /// Speech Style
  /// Style guidance for speech generation
  final String? speechStyle;

  const PreToolSpeechConfig({
    this.enabled,
    this.mode,
    this.constantMessage,
    this.randomMessages,
    this.contextScope,
    this.llmInstruction,
    this.includeToolParams,
    this.includeUserIntent,
    this.maxTokens,
    this.temperature,
    this.speechStyle,
  });

  factory PreToolSpeechConfig.fromJson(Map<String, dynamic> json) {
    return PreToolSpeechConfig(
      enabled: json['enabled'] as bool?,
      mode: json['mode'] != null
          ? SpeechMode.fromJson(json['mode'] as Map<String, dynamic>)
          : null,
      constantMessage: json['constant_message'] as String?,
      randomMessages: (json['random_messages'] as List?)?.cast<String>(),
      contextScope: json['context_scope'] != null
          ? SpeechContextScope.fromJson(json['context_scope'] as Map<String, dynamic>)
          : null,
      llmInstruction: json['llm_instruction'] as String?,
      includeToolParams: json['include_tool_params'] as bool?,
      includeUserIntent: json['include_user_intent'] as bool?,
      maxTokens: json['max_tokens'] as int?,
      temperature: (json['temperature'] as num?)?.toDouble(),
      speechStyle: json['speech_style'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      if (enabled != null) 'enabled': enabled,
      if (mode != null) 'mode': mode!.toJson(),
      if (constantMessage != null) 'constant_message': constantMessage,
      if (randomMessages != null) 'random_messages': randomMessages,
      if (contextScope != null) 'context_scope': contextScope!.toJson(),
      if (llmInstruction != null) 'llm_instruction': llmInstruction,
      if (includeToolParams != null) 'include_tool_params': includeToolParams,
      if (includeUserIntent != null) 'include_user_intent': includeUserIntent,
      if (maxTokens != null) 'max_tokens': maxTokens,
      if (temperature != null) 'temperature': temperature,
      if (speechStyle != null) 'speech_style': speechStyle,
    };
  }

  PreToolSpeechConfig copyWith({
    bool? enabled,
    SpeechMode? mode,
    String? constantMessage,
    List<String>? randomMessages,
    SpeechContextScope? contextScope,
    String? llmInstruction,
    bool? includeToolParams,
    bool? includeUserIntent,
    int? maxTokens,
    double? temperature,
    String? speechStyle,
  }}) {
    return PreToolSpeechConfig(
      enabled: enabled ?? this.enabled,
      mode: mode ?? this.mode,
      constantMessage: constantMessage ?? this.constantMessage,
      randomMessages: randomMessages ?? this.randomMessages,
      contextScope: contextScope ?? this.contextScope,
      llmInstruction: llmInstruction ?? this.llmInstruction,
      includeToolParams: includeToolParams ?? this.includeToolParams,
      includeUserIntent: includeUserIntent ?? this.includeUserIntent,
      maxTokens: maxTokens ?? this.maxTokens,
      temperature: temperature ?? this.temperature,
      speechStyle: speechStyle ?? this.speechStyle,
    );
  }

  factory PreToolSpeechConfig.empty() {
    return const PreToolSpeechConfig();
  }
}

class ExecutionConfig {
  /// Execution Mode
  /// Whether to wait for speech (sequential) or run in parallel
  final ExecutionMode? mode;
  /// Speech Timeout (ms)
  /// Max time to wait for speech in sequential mode
  final int? speechTimeoutMs;

  const ExecutionConfig({
    this.mode,
    this.speechTimeoutMs,
  });

  factory ExecutionConfig.fromJson(Map<String, dynamic> json) {
    return ExecutionConfig(
      mode: json['mode'] != null
          ? ExecutionMode.fromJson(json['mode'] as Map<String, dynamic>)
          : null,
      speechTimeoutMs: json['speech_timeout_ms'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      if (mode != null) 'mode': mode!.toJson(),
      if (speechTimeoutMs != null) 'speech_timeout_ms': speechTimeoutMs,
    };
  }

  ExecutionConfig copyWith({
    ExecutionMode? mode,
    int? speechTimeoutMs,
  }}) {
    return ExecutionConfig(
      mode: mode ?? this.mode,
      speechTimeoutMs: speechTimeoutMs ?? this.speechTimeoutMs,
    );
  }

  factory ExecutionConfig.empty() {
    return const ExecutionConfig();
  }
}

class VariableAssignment {
  /// Target Variable
  /// Name of the dynamic variable to update
  final String targetVariable;
  /// Source Field
  /// Path to field in tool result (dot notation)
  final String sourceField;
  /// Operator
  /// How to assign the value
  final VariableAssignmentOperator? operator;
  /// Default Value
  /// Default value if source field not found
  final String? defaultValue;
  /// Transform Expression
  /// Simple transformation expression (e.g., 'bool(value)', 'str(value)')
  final String? transformExpr;
  /// Transform Function
  /// Custom callable for complex transformations (set programmatically)
  final String? transformFunc;
  /// Transform Execution
  /// Execution mode for transform_func
  final TransformExecutionMode? transformExecution;

  const VariableAssignment({
    required this.targetVariable,
    required this.sourceField,
    this.operator,
    this.defaultValue,
    this.transformExpr,
    this.transformFunc,
    this.transformExecution,
  });

  factory VariableAssignment.fromJson(Map<String, dynamic> json) {
    return VariableAssignment(
      targetVariable: json['target_variable'] as String?,
      sourceField: json['source_field'] as String?,
      operator: json['operator'] != null
          ? VariableAssignmentOperator.fromJson(json['operator'] as Map<String, dynamic>)
          : null,
      defaultValue: json['default_value'] as String?,
      transformExpr: json['transform_expr'] as String?,
      transformFunc: json['transform_func'] as String?,
      transformExecution: json['transform_execution'] != null
          ? TransformExecutionMode.fromJson(json['transform_execution'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      if (targetVariable != null) 'target_variable': targetVariable,
      if (sourceField != null) 'source_field': sourceField,
      if (operator != null) 'operator': operator!.toJson(),
      if (defaultValue != null) 'default_value': defaultValue,
      if (transformExpr != null) 'transform_expr': transformExpr,
      if (transformFunc != null) 'transform_func': transformFunc,
      if (transformExecution != null) 'transform_execution': transformExecution!.toJson(),
    };
  }

  VariableAssignment copyWith({
    String? targetVariable,
    String? sourceField,
    VariableAssignmentOperator? operator,
    String? defaultValue,
    String? transformExpr,
    String? transformFunc,
    TransformExecutionMode? transformExecution,
  }}) {
    return VariableAssignment(
      targetVariable: targetVariable ?? this.targetVariable,
      sourceField: sourceField ?? this.sourceField,
      operator: operator ?? this.operator,
      defaultValue: defaultValue ?? this.defaultValue,
      transformExpr: transformExpr ?? this.transformExpr,
      transformFunc: transformFunc ?? this.transformFunc,
      transformExecution: transformExecution ?? this.transformExecution,
    );
  }

  factory VariableAssignment.empty() {
    return const VariableAssignment();
  }
}

class DynamicVariableConfig {
  /// Enable Dynamic Variables
  /// Update conversation/session variables based on tool results
  final bool? enabled;
  /// Variable Assignments
  /// List of variable assignment rules
  final List<VariableAssignment>? assignments;
  /// On Error
  /// Behavior on assignment error
  final String? onError;

  const DynamicVariableConfig({
    this.enabled,
    this.assignments,
    this.onError,
  });

  factory DynamicVariableConfig.fromJson(Map<String, dynamic> json) {
    return DynamicVariableConfig(
      enabled: json['enabled'] as bool?,
      assignments: (json['assignments'] as List?)
          ?.map((e) => VariableAssignment.fromJson(e as Map<String, dynamic>))
          .toList(),
      onError: json['on_error'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      if (enabled != null) 'enabled': enabled,
      if (assignments != null) 'assignments': assignments!.map((e) => e.toJson()).toList(),
      if (onError != null) 'on_error': onError,
    };
  }

  DynamicVariableConfig copyWith({
    bool? enabled,
    List<VariableAssignment>? assignments,
    String? onError,
  }}) {
    return DynamicVariableConfig(
      enabled: enabled ?? this.enabled,
      assignments: assignments ?? this.assignments,
      onError: onError ?? this.onError,
    );
  }

  factory DynamicVariableConfig.empty() {
    return const DynamicVariableConfig();
  }
}
