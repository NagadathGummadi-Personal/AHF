// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by scripts/generate_flutter.py

// ignore_for_file: unnecessary_this

class ToolSpec {
  /// Tool ID
  /// Unique identifier for the tool (auto-generated from name)
  final String id;
  /// Version
  /// Tool version string (semver recommended)
  final String? version;
  /// Display Name
  /// Human-readable tool name
  final String toolName;
  /// Description
  /// Tool description (helps LLM understand when to use it)
  final String description;
  /// Tool Type
  /// Type of tool implementation
  final ToolType toolType;
  /// Parameters
  /// Input parameters for this tool
  final List<ToolParameter>? parameters;
  /// Return Type
  /// Format of tool output
  final ToolReturnType? returns;
  /// Return Target
  /// Where to route tool output
  final ToolReturnTarget? returnTarget;
  /// Required Tool
  /// Whether this tool must be available for the agent
  final bool? required;
  /// Owner
  /// Tool owner identifier
  final String? owner;
  /// Required Permissions
  /// Permissions required to use this tool
  final List<String>? permissions;
  /// Timeout (seconds)
  /// Maximum execution time before timeout
  final int? timeoutS;
  /// Usage Examples
  /// Example inputs/outputs for documentation
  final List<Map<String, dynamic>>? examples;
  /// Retry Configuration
  /// Configure automatic retry behavior
  final RetryConfig? retry;
  /// Circuit Breaker
  /// Configure circuit breaker pattern
  final CircuitBreakerConfig? circuitBreaker;
  /// Idempotency
  /// Configure idempotency behavior
  final IdempotencyConfig? idempotency;
  final String? idempotencyKeyGenerator;
  final String? circuitBreakerPolicy;
  final String? retryPolicy;
  /// Metrics Tags
  /// Static tags for metrics/observability
  final Map<String, String>? metricsTags;
  /// Interruption Control
  /// Controls whether user input can interrupt tool execution
  final InterruptionConfig? interruption;
  /// Pre-Tool Speech
  /// Configuration for what agent says before executing tool
  final PreToolSpeechConfig? preToolSpeech;
  /// Execution Mode
  /// Controls speech/execution timing
  final ExecutionConfig? execution;
  /// Dynamic Variables
  /// Configuration for updating variables based on tool results
  final DynamicVariableConfig? dynamicVariables;

  const ToolSpec({
    required this.id,
    this.version,
    required this.toolName,
    required this.description,
    required this.toolType,
    this.parameters,
    this.returns,
    this.returnTarget,
    this.required,
    this.owner,
    this.permissions,
    this.timeoutS,
    this.examples,
    this.retry,
    this.circuitBreaker,
    this.idempotency,
    this.idempotencyKeyGenerator,
    this.circuitBreakerPolicy,
    this.retryPolicy,
    this.metricsTags,
    this.interruption,
    this.preToolSpeech,
    this.execution,
    this.dynamicVariables,
  });

  factory ToolSpec.fromJson(Map<String, dynamic> json) {
    return ToolSpec(
      id: json['id'] as String?,
      version: json['version'] as String?,
      toolName: json['tool_name'] as String?,
      description: json['description'] as String?,
      toolType: json['tool_type'] != null
          ? ToolType.fromJson(json['tool_type'] as Map<String, dynamic>)
          : null,
      parameters: (json['parameters'] as List?)
          ?.map((e) => ToolParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
      returns: json['returns'] != null
          ? ToolReturnType.fromJson(json['returns'] as Map<String, dynamic>)
          : null,
      returnTarget: json['return_target'] != null
          ? ToolReturnTarget.fromJson(json['return_target'] as Map<String, dynamic>)
          : null,
      required: json['required'] as bool?,
      owner: json['owner'] as String?,
      permissions: (json['permissions'] as List?)?.cast<String>(),
      timeoutS: json['timeout_s'] as int?,
      examples: (json['examples'] as List?)
          ?.map((e) => Map<String, dynamic>.fromJson(e as Map<String, dynamic>))
          .toList(),
      retry: json['retry'] != null
          ? RetryConfig.fromJson(json['retry'] as Map<String, dynamic>)
          : null,
      circuitBreaker: json['circuit_breaker'] != null
          ? CircuitBreakerConfig.fromJson(json['circuit_breaker'] as Map<String, dynamic>)
          : null,
      idempotency: json['idempotency'] != null
          ? IdempotencyConfig.fromJson(json['idempotency'] as Map<String, dynamic>)
          : null,
      idempotencyKeyGenerator: json['idempotency_key_generator'] as String?,
      circuitBreakerPolicy: json['circuit_breaker_policy'] as String?,
      retryPolicy: json['retry_policy'] as String?,
      metricsTags: json['metrics_tags'] != null
          ? Map<String, dynamic>.from(json['metrics_tags'])
          : null,
      interruption: json['interruption'] != null
          ? InterruptionConfig.fromJson(json['interruption'] as Map<String, dynamic>)
          : null,
      preToolSpeech: json['pre_tool_speech'] != null
          ? PreToolSpeechConfig.fromJson(json['pre_tool_speech'] as Map<String, dynamic>)
          : null,
      execution: json['execution'] != null
          ? ExecutionConfig.fromJson(json['execution'] as Map<String, dynamic>)
          : null,
      dynamicVariables: json['dynamic_variables'] != null
          ? DynamicVariableConfig.fromJson(json['dynamic_variables'] as Map<String, dynamic>)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      if (id != null) 'id': id,
      if (version != null) 'version': version,
      if (toolName != null) 'tool_name': toolName,
      if (description != null) 'description': description,
      if (toolType != null) 'tool_type': toolType!.toJson(),
      if (parameters != null) 'parameters': parameters!.map((e) => e.toJson()).toList(),
      if (returns != null) 'returns': returns!.toJson(),
      if (returnTarget != null) 'return_target': returnTarget!.toJson(),
      if (required != null) 'required': required,
      if (owner != null) 'owner': owner,
      if (permissions != null) 'permissions': permissions,
      if (timeoutS != null) 'timeout_s': timeoutS,
      if (examples != null) 'examples': examples!.map((e) => e.toJson()).toList(),
      if (retry != null) 'retry': retry!.toJson(),
      if (circuitBreaker != null) 'circuit_breaker': circuitBreaker!.toJson(),
      if (idempotency != null) 'idempotency': idempotency!.toJson(),
      if (idempotencyKeyGenerator != null) 'idempotency_key_generator': idempotencyKeyGenerator,
      if (circuitBreakerPolicy != null) 'circuit_breaker_policy': circuitBreakerPolicy,
      if (retryPolicy != null) 'retry_policy': retryPolicy,
      if (metricsTags != null) 'metrics_tags': metricsTags,
      if (interruption != null) 'interruption': interruption!.toJson(),
      if (preToolSpeech != null) 'pre_tool_speech': preToolSpeech!.toJson(),
      if (execution != null) 'execution': execution!.toJson(),
      if (dynamicVariables != null) 'dynamic_variables': dynamicVariables!.toJson(),
    };
  }

  ToolSpec copyWith({
    String? id,
    String? version,
    String? toolName,
    String? description,
    ToolType? toolType,
    List<ToolParameter>? parameters,
    ToolReturnType? returns,
    ToolReturnTarget? returnTarget,
    bool? required,
    String? owner,
    List<String>? permissions,
    int? timeoutS,
    List<Map<String, dynamic>>? examples,
    RetryConfig? retry,
    CircuitBreakerConfig? circuitBreaker,
    IdempotencyConfig? idempotency,
    String? idempotencyKeyGenerator,
    String? circuitBreakerPolicy,
    String? retryPolicy,
    Map<String, String>? metricsTags,
    InterruptionConfig? interruption,
    PreToolSpeechConfig? preToolSpeech,
    ExecutionConfig? execution,
    DynamicVariableConfig? dynamicVariables,
  }}) {
    return ToolSpec(
      id: id ?? this.id,
      version: version ?? this.version,
      toolName: toolName ?? this.toolName,
      description: description ?? this.description,
      toolType: toolType ?? this.toolType,
      parameters: parameters ?? this.parameters,
      returns: returns ?? this.returns,
      returnTarget: returnTarget ?? this.returnTarget,
      required: required ?? this.required,
      owner: owner ?? this.owner,
      permissions: permissions ?? this.permissions,
      timeoutS: timeoutS ?? this.timeoutS,
      examples: examples ?? this.examples,
      retry: retry ?? this.retry,
      circuitBreaker: circuitBreaker ?? this.circuitBreaker,
      idempotency: idempotency ?? this.idempotency,
      idempotencyKeyGenerator: idempotencyKeyGenerator ?? this.idempotencyKeyGenerator,
      circuitBreakerPolicy: circuitBreakerPolicy ?? this.circuitBreakerPolicy,
      retryPolicy: retryPolicy ?? this.retryPolicy,
      metricsTags: metricsTags ?? this.metricsTags,
      interruption: interruption ?? this.interruption,
      preToolSpeech: preToolSpeech ?? this.preToolSpeech,
      execution: execution ?? this.execution,
      dynamicVariables: dynamicVariables ?? this.dynamicVariables,
    );
  }

  factory ToolSpec.empty() {
    return const ToolSpec();
  }
}

class FunctionToolSpec {
  /// Tool ID
  /// Unique identifier for the tool (auto-generated from name)
  final String id;
  /// Version
  /// Tool version string (semver recommended)
  final String? version;
  /// Display Name
  /// Human-readable tool name
  final String toolName;
  /// Description
  /// Tool description (helps LLM understand when to use it)
  final String description;
  final ToolType? toolType;
  /// Parameters
  /// Input parameters for this tool
  final List<ToolParameter>? parameters;
  /// Return Type
  /// Format of tool output
  final ToolReturnType? returns;
  /// Return Target
  /// Where to route tool output
  final ToolReturnTarget? returnTarget;
  /// Required Tool
  /// Whether this tool must be available for the agent
  final bool? required;
  /// Owner
  /// Tool owner identifier
  final String? owner;
  /// Required Permissions
  /// Permissions required to use this tool
  final List<String>? permissions;
  /// Timeout (seconds)
  /// Maximum execution time before timeout
  final int? timeoutS;
  /// Usage Examples
  /// Example inputs/outputs for documentation
  final List<Map<String, dynamic>>? examples;
  /// Retry Configuration
  /// Configure automatic retry behavior
  final RetryConfig? retry;
  /// Circuit Breaker
  /// Configure circuit breaker pattern
  final CircuitBreakerConfig? circuitBreaker;
  /// Idempotency
  /// Configure idempotency behavior
  final IdempotencyConfig? idempotency;
  final String? idempotencyKeyGenerator;
  final String? circuitBreakerPolicy;
  final String? retryPolicy;
  /// Metrics Tags
  /// Static tags for metrics/observability
  final Map<String, String>? metricsTags;
  /// Interruption Control
  /// Controls whether user input can interrupt tool execution
  final InterruptionConfig? interruption;
  /// Pre-Tool Speech
  /// Configuration for what agent says before executing tool
  final PreToolSpeechConfig? preToolSpeech;
  /// Execution Mode
  /// Controls speech/execution timing
  final ExecutionConfig? execution;
  /// Dynamic Variables
  /// Configuration for updating variables based on tool results
  final DynamicVariableConfig? dynamicVariables;
  /// Function Code
  /// Python async function implementation
  final String? functionCode;

  const FunctionToolSpec({
    required this.id,
    this.version,
    required this.toolName,
    required this.description,
    this.toolType,
    this.parameters,
    this.returns,
    this.returnTarget,
    this.required,
    this.owner,
    this.permissions,
    this.timeoutS,
    this.examples,
    this.retry,
    this.circuitBreaker,
    this.idempotency,
    this.idempotencyKeyGenerator,
    this.circuitBreakerPolicy,
    this.retryPolicy,
    this.metricsTags,
    this.interruption,
    this.preToolSpeech,
    this.execution,
    this.dynamicVariables,
    this.functionCode,
  });

  factory FunctionToolSpec.fromJson(Map<String, dynamic> json) {
    return FunctionToolSpec(
      id: json['id'] as String?,
      version: json['version'] as String?,
      toolName: json['tool_name'] as String?,
      description: json['description'] as String?,
      toolType: json['tool_type'] != null
          ? ToolType.fromJson(json['tool_type'] as Map<String, dynamic>)
          : null,
      parameters: (json['parameters'] as List?)
          ?.map((e) => ToolParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
      returns: json['returns'] != null
          ? ToolReturnType.fromJson(json['returns'] as Map<String, dynamic>)
          : null,
      returnTarget: json['return_target'] != null
          ? ToolReturnTarget.fromJson(json['return_target'] as Map<String, dynamic>)
          : null,
      required: json['required'] as bool?,
      owner: json['owner'] as String?,
      permissions: (json['permissions'] as List?)?.cast<String>(),
      timeoutS: json['timeout_s'] as int?,
      examples: (json['examples'] as List?)
          ?.map((e) => Map<String, dynamic>.fromJson(e as Map<String, dynamic>))
          .toList(),
      retry: json['retry'] != null
          ? RetryConfig.fromJson(json['retry'] as Map<String, dynamic>)
          : null,
      circuitBreaker: json['circuit_breaker'] != null
          ? CircuitBreakerConfig.fromJson(json['circuit_breaker'] as Map<String, dynamic>)
          : null,
      idempotency: json['idempotency'] != null
          ? IdempotencyConfig.fromJson(json['idempotency'] as Map<String, dynamic>)
          : null,
      idempotencyKeyGenerator: json['idempotency_key_generator'] as String?,
      circuitBreakerPolicy: json['circuit_breaker_policy'] as String?,
      retryPolicy: json['retry_policy'] as String?,
      metricsTags: json['metrics_tags'] != null
          ? Map<String, dynamic>.from(json['metrics_tags'])
          : null,
      interruption: json['interruption'] != null
          ? InterruptionConfig.fromJson(json['interruption'] as Map<String, dynamic>)
          : null,
      preToolSpeech: json['pre_tool_speech'] != null
          ? PreToolSpeechConfig.fromJson(json['pre_tool_speech'] as Map<String, dynamic>)
          : null,
      execution: json['execution'] != null
          ? ExecutionConfig.fromJson(json['execution'] as Map<String, dynamic>)
          : null,
      dynamicVariables: json['dynamic_variables'] != null
          ? DynamicVariableConfig.fromJson(json['dynamic_variables'] as Map<String, dynamic>)
          : null,
      functionCode: json['function_code'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      if (id != null) 'id': id,
      if (version != null) 'version': version,
      if (toolName != null) 'tool_name': toolName,
      if (description != null) 'description': description,
      if (toolType != null) 'tool_type': toolType!.toJson(),
      if (parameters != null) 'parameters': parameters!.map((e) => e.toJson()).toList(),
      if (returns != null) 'returns': returns!.toJson(),
      if (returnTarget != null) 'return_target': returnTarget!.toJson(),
      if (required != null) 'required': required,
      if (owner != null) 'owner': owner,
      if (permissions != null) 'permissions': permissions,
      if (timeoutS != null) 'timeout_s': timeoutS,
      if (examples != null) 'examples': examples!.map((e) => e.toJson()).toList(),
      if (retry != null) 'retry': retry!.toJson(),
      if (circuitBreaker != null) 'circuit_breaker': circuitBreaker!.toJson(),
      if (idempotency != null) 'idempotency': idempotency!.toJson(),
      if (idempotencyKeyGenerator != null) 'idempotency_key_generator': idempotencyKeyGenerator,
      if (circuitBreakerPolicy != null) 'circuit_breaker_policy': circuitBreakerPolicy,
      if (retryPolicy != null) 'retry_policy': retryPolicy,
      if (metricsTags != null) 'metrics_tags': metricsTags,
      if (interruption != null) 'interruption': interruption!.toJson(),
      if (preToolSpeech != null) 'pre_tool_speech': preToolSpeech!.toJson(),
      if (execution != null) 'execution': execution!.toJson(),
      if (dynamicVariables != null) 'dynamic_variables': dynamicVariables!.toJson(),
      if (functionCode != null) 'function_code': functionCode,
    };
  }

  FunctionToolSpec copyWith({
    String? id,
    String? version,
    String? toolName,
    String? description,
    ToolType? toolType,
    List<ToolParameter>? parameters,
    ToolReturnType? returns,
    ToolReturnTarget? returnTarget,
    bool? required,
    String? owner,
    List<String>? permissions,
    int? timeoutS,
    List<Map<String, dynamic>>? examples,
    RetryConfig? retry,
    CircuitBreakerConfig? circuitBreaker,
    IdempotencyConfig? idempotency,
    String? idempotencyKeyGenerator,
    String? circuitBreakerPolicy,
    String? retryPolicy,
    Map<String, String>? metricsTags,
    InterruptionConfig? interruption,
    PreToolSpeechConfig? preToolSpeech,
    ExecutionConfig? execution,
    DynamicVariableConfig? dynamicVariables,
    String? functionCode,
  }}) {
    return FunctionToolSpec(
      id: id ?? this.id,
      version: version ?? this.version,
      toolName: toolName ?? this.toolName,
      description: description ?? this.description,
      toolType: toolType ?? this.toolType,
      parameters: parameters ?? this.parameters,
      returns: returns ?? this.returns,
      returnTarget: returnTarget ?? this.returnTarget,
      required: required ?? this.required,
      owner: owner ?? this.owner,
      permissions: permissions ?? this.permissions,
      timeoutS: timeoutS ?? this.timeoutS,
      examples: examples ?? this.examples,
      retry: retry ?? this.retry,
      circuitBreaker: circuitBreaker ?? this.circuitBreaker,
      idempotency: idempotency ?? this.idempotency,
      idempotencyKeyGenerator: idempotencyKeyGenerator ?? this.idempotencyKeyGenerator,
      circuitBreakerPolicy: circuitBreakerPolicy ?? this.circuitBreakerPolicy,
      retryPolicy: retryPolicy ?? this.retryPolicy,
      metricsTags: metricsTags ?? this.metricsTags,
      interruption: interruption ?? this.interruption,
      preToolSpeech: preToolSpeech ?? this.preToolSpeech,
      execution: execution ?? this.execution,
      dynamicVariables: dynamicVariables ?? this.dynamicVariables,
      functionCode: functionCode ?? this.functionCode,
    );
  }

  factory FunctionToolSpec.empty() {
    return const FunctionToolSpec();
  }
}

class HttpToolSpec {
  /// Tool ID
  /// Unique identifier for the tool (auto-generated from name)
  final String id;
  /// Version
  /// Tool version string (semver recommended)
  final String? version;
  /// Display Name
  /// Human-readable tool name
  final String toolName;
  /// Description
  /// Tool description (helps LLM understand when to use it)
  final String description;
  final ToolType? toolType;
  /// Parameters
  /// Input parameters for this tool
  final List<ToolParameter>? parameters;
  /// Return Type
  /// Format of tool output
  final ToolReturnType? returns;
  /// Return Target
  /// Where to route tool output
  final ToolReturnTarget? returnTarget;
  /// Required Tool
  /// Whether this tool must be available for the agent
  final bool? required;
  /// Owner
  /// Tool owner identifier
  final String? owner;
  /// Required Permissions
  /// Permissions required to use this tool
  final List<String>? permissions;
  /// Timeout (seconds)
  /// Maximum execution time before timeout
  final int? timeoutS;
  /// Usage Examples
  /// Example inputs/outputs for documentation
  final List<Map<String, dynamic>>? examples;
  /// Retry Configuration
  /// Configure automatic retry behavior
  final RetryConfig? retry;
  /// Circuit Breaker
  /// Configure circuit breaker pattern
  final CircuitBreakerConfig? circuitBreaker;
  /// Idempotency
  /// Configure idempotency behavior
  final IdempotencyConfig? idempotency;
  final String? idempotencyKeyGenerator;
  final String? circuitBreakerPolicy;
  final String? retryPolicy;
  /// Metrics Tags
  /// Static tags for metrics/observability
  final Map<String, String>? metricsTags;
  /// Interruption Control
  /// Controls whether user input can interrupt tool execution
  final InterruptionConfig? interruption;
  /// Pre-Tool Speech
  /// Configuration for what agent says before executing tool
  final PreToolSpeechConfig? preToolSpeech;
  /// Execution Mode
  /// Controls speech/execution timing
  final ExecutionConfig? execution;
  /// Dynamic Variables
  /// Configuration for updating variables based on tool results
  final DynamicVariableConfig? dynamicVariables;
  /// URL
  /// API endpoint URL (supports {variable} substitution)
  final String url;
  /// HTTP Method
  /// HTTP request method
  final String? method;
  /// Headers
  /// HTTP headers (use ${VAR} for variable substitution)
  final Map<String, String>? headers;
  /// Query Parameters
  /// URL query parameters
  final Map<String, String>? queryParams;
  /// Request Body
  /// JSON request body template
  final Map<String, dynamic>? body;

  const HttpToolSpec({
    required this.id,
    this.version,
    required this.toolName,
    required this.description,
    this.toolType,
    this.parameters,
    this.returns,
    this.returnTarget,
    this.required,
    this.owner,
    this.permissions,
    this.timeoutS,
    this.examples,
    this.retry,
    this.circuitBreaker,
    this.idempotency,
    this.idempotencyKeyGenerator,
    this.circuitBreakerPolicy,
    this.retryPolicy,
    this.metricsTags,
    this.interruption,
    this.preToolSpeech,
    this.execution,
    this.dynamicVariables,
    required this.url,
    this.method,
    this.headers,
    this.queryParams,
    this.body,
  });

  factory HttpToolSpec.fromJson(Map<String, dynamic> json) {
    return HttpToolSpec(
      id: json['id'] as String?,
      version: json['version'] as String?,
      toolName: json['tool_name'] as String?,
      description: json['description'] as String?,
      toolType: json['tool_type'] != null
          ? ToolType.fromJson(json['tool_type'] as Map<String, dynamic>)
          : null,
      parameters: (json['parameters'] as List?)
          ?.map((e) => ToolParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
      returns: json['returns'] != null
          ? ToolReturnType.fromJson(json['returns'] as Map<String, dynamic>)
          : null,
      returnTarget: json['return_target'] != null
          ? ToolReturnTarget.fromJson(json['return_target'] as Map<String, dynamic>)
          : null,
      required: json['required'] as bool?,
      owner: json['owner'] as String?,
      permissions: (json['permissions'] as List?)?.cast<String>(),
      timeoutS: json['timeout_s'] as int?,
      examples: (json['examples'] as List?)
          ?.map((e) => Map<String, dynamic>.fromJson(e as Map<String, dynamic>))
          .toList(),
      retry: json['retry'] != null
          ? RetryConfig.fromJson(json['retry'] as Map<String, dynamic>)
          : null,
      circuitBreaker: json['circuit_breaker'] != null
          ? CircuitBreakerConfig.fromJson(json['circuit_breaker'] as Map<String, dynamic>)
          : null,
      idempotency: json['idempotency'] != null
          ? IdempotencyConfig.fromJson(json['idempotency'] as Map<String, dynamic>)
          : null,
      idempotencyKeyGenerator: json['idempotency_key_generator'] as String?,
      circuitBreakerPolicy: json['circuit_breaker_policy'] as String?,
      retryPolicy: json['retry_policy'] as String?,
      metricsTags: json['metrics_tags'] != null
          ? Map<String, dynamic>.from(json['metrics_tags'])
          : null,
      interruption: json['interruption'] != null
          ? InterruptionConfig.fromJson(json['interruption'] as Map<String, dynamic>)
          : null,
      preToolSpeech: json['pre_tool_speech'] != null
          ? PreToolSpeechConfig.fromJson(json['pre_tool_speech'] as Map<String, dynamic>)
          : null,
      execution: json['execution'] != null
          ? ExecutionConfig.fromJson(json['execution'] as Map<String, dynamic>)
          : null,
      dynamicVariables: json['dynamic_variables'] != null
          ? DynamicVariableConfig.fromJson(json['dynamic_variables'] as Map<String, dynamic>)
          : null,
      url: json['url'] as String?,
      method: json['method'] as String?,
      headers: json['headers'] != null
          ? Map<String, dynamic>.from(json['headers'])
          : null,
      queryParams: json['query_params'] != null
          ? Map<String, dynamic>.from(json['query_params'])
          : null,
      body: json['body'] != null
          ? Map<String, dynamic>.from(json['body'])
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      if (id != null) 'id': id,
      if (version != null) 'version': version,
      if (toolName != null) 'tool_name': toolName,
      if (description != null) 'description': description,
      if (toolType != null) 'tool_type': toolType!.toJson(),
      if (parameters != null) 'parameters': parameters!.map((e) => e.toJson()).toList(),
      if (returns != null) 'returns': returns!.toJson(),
      if (returnTarget != null) 'return_target': returnTarget!.toJson(),
      if (required != null) 'required': required,
      if (owner != null) 'owner': owner,
      if (permissions != null) 'permissions': permissions,
      if (timeoutS != null) 'timeout_s': timeoutS,
      if (examples != null) 'examples': examples!.map((e) => e.toJson()).toList(),
      if (retry != null) 'retry': retry!.toJson(),
      if (circuitBreaker != null) 'circuit_breaker': circuitBreaker!.toJson(),
      if (idempotency != null) 'idempotency': idempotency!.toJson(),
      if (idempotencyKeyGenerator != null) 'idempotency_key_generator': idempotencyKeyGenerator,
      if (circuitBreakerPolicy != null) 'circuit_breaker_policy': circuitBreakerPolicy,
      if (retryPolicy != null) 'retry_policy': retryPolicy,
      if (metricsTags != null) 'metrics_tags': metricsTags,
      if (interruption != null) 'interruption': interruption!.toJson(),
      if (preToolSpeech != null) 'pre_tool_speech': preToolSpeech!.toJson(),
      if (execution != null) 'execution': execution!.toJson(),
      if (dynamicVariables != null) 'dynamic_variables': dynamicVariables!.toJson(),
      if (url != null) 'url': url,
      if (method != null) 'method': method,
      if (headers != null) 'headers': headers,
      if (queryParams != null) 'query_params': queryParams,
      if (body != null) 'body': body,
    };
  }

  HttpToolSpec copyWith({
    String? id,
    String? version,
    String? toolName,
    String? description,
    ToolType? toolType,
    List<ToolParameter>? parameters,
    ToolReturnType? returns,
    ToolReturnTarget? returnTarget,
    bool? required,
    String? owner,
    List<String>? permissions,
    int? timeoutS,
    List<Map<String, dynamic>>? examples,
    RetryConfig? retry,
    CircuitBreakerConfig? circuitBreaker,
    IdempotencyConfig? idempotency,
    String? idempotencyKeyGenerator,
    String? circuitBreakerPolicy,
    String? retryPolicy,
    Map<String, String>? metricsTags,
    InterruptionConfig? interruption,
    PreToolSpeechConfig? preToolSpeech,
    ExecutionConfig? execution,
    DynamicVariableConfig? dynamicVariables,
    String? url,
    String? method,
    Map<String, String>? headers,
    Map<String, String>? queryParams,
    Map<String, dynamic>? body,
  }}) {
    return HttpToolSpec(
      id: id ?? this.id,
      version: version ?? this.version,
      toolName: toolName ?? this.toolName,
      description: description ?? this.description,
      toolType: toolType ?? this.toolType,
      parameters: parameters ?? this.parameters,
      returns: returns ?? this.returns,
      returnTarget: returnTarget ?? this.returnTarget,
      required: required ?? this.required,
      owner: owner ?? this.owner,
      permissions: permissions ?? this.permissions,
      timeoutS: timeoutS ?? this.timeoutS,
      examples: examples ?? this.examples,
      retry: retry ?? this.retry,
      circuitBreaker: circuitBreaker ?? this.circuitBreaker,
      idempotency: idempotency ?? this.idempotency,
      idempotencyKeyGenerator: idempotencyKeyGenerator ?? this.idempotencyKeyGenerator,
      circuitBreakerPolicy: circuitBreakerPolicy ?? this.circuitBreakerPolicy,
      retryPolicy: retryPolicy ?? this.retryPolicy,
      metricsTags: metricsTags ?? this.metricsTags,
      interruption: interruption ?? this.interruption,
      preToolSpeech: preToolSpeech ?? this.preToolSpeech,
      execution: execution ?? this.execution,
      dynamicVariables: dynamicVariables ?? this.dynamicVariables,
      url: url ?? this.url,
      method: method ?? this.method,
      headers: headers ?? this.headers,
      queryParams: queryParams ?? this.queryParams,
      body: body ?? this.body,
    );
  }

  factory HttpToolSpec.empty() {
    return const HttpToolSpec();
  }
}

class DbToolSpec {
  /// Tool ID
  /// Unique identifier for the tool (auto-generated from name)
  final String id;
  /// Version
  /// Tool version string (semver recommended)
  final String? version;
  /// Display Name
  /// Human-readable tool name
  final String toolName;
  /// Description
  /// Tool description (helps LLM understand when to use it)
  final String description;
  final ToolType? toolType;
  /// Parameters
  /// Input parameters for this tool
  final List<ToolParameter>? parameters;
  /// Return Type
  /// Format of tool output
  final ToolReturnType? returns;
  /// Return Target
  /// Where to route tool output
  final ToolReturnTarget? returnTarget;
  /// Required Tool
  /// Whether this tool must be available for the agent
  final bool? required;
  /// Owner
  /// Tool owner identifier
  final String? owner;
  /// Required Permissions
  /// Permissions required to use this tool
  final List<String>? permissions;
  /// Timeout (seconds)
  /// Maximum execution time before timeout
  final int? timeoutS;
  /// Usage Examples
  /// Example inputs/outputs for documentation
  final List<Map<String, dynamic>>? examples;
  /// Retry Configuration
  /// Configure automatic retry behavior
  final RetryConfig? retry;
  /// Circuit Breaker
  /// Configure circuit breaker pattern
  final CircuitBreakerConfig? circuitBreaker;
  /// Idempotency
  /// Configure idempotency behavior
  final IdempotencyConfig? idempotency;
  final String? idempotencyKeyGenerator;
  final String? circuitBreakerPolicy;
  final String? retryPolicy;
  /// Metrics Tags
  /// Static tags for metrics/observability
  final Map<String, String>? metricsTags;
  /// Interruption Control
  /// Controls whether user input can interrupt tool execution
  final InterruptionConfig? interruption;
  /// Pre-Tool Speech
  /// Configuration for what agent says before executing tool
  final PreToolSpeechConfig? preToolSpeech;
  /// Execution Mode
  /// Controls speech/execution timing
  final ExecutionConfig? execution;
  /// Dynamic Variables
  /// Configuration for updating variables based on tool results
  final DynamicVariableConfig? dynamicVariables;
  /// Database Driver
  /// Database driver/provider
  final String? driver;

  const DbToolSpec({
    required this.id,
    this.version,
    required this.toolName,
    required this.description,
    this.toolType,
    this.parameters,
    this.returns,
    this.returnTarget,
    this.required,
    this.owner,
    this.permissions,
    this.timeoutS,
    this.examples,
    this.retry,
    this.circuitBreaker,
    this.idempotency,
    this.idempotencyKeyGenerator,
    this.circuitBreakerPolicy,
    this.retryPolicy,
    this.metricsTags,
    this.interruption,
    this.preToolSpeech,
    this.execution,
    this.dynamicVariables,
    this.driver,
  });

  factory DbToolSpec.fromJson(Map<String, dynamic> json) {
    return DbToolSpec(
      id: json['id'] as String?,
      version: json['version'] as String?,
      toolName: json['tool_name'] as String?,
      description: json['description'] as String?,
      toolType: json['tool_type'] != null
          ? ToolType.fromJson(json['tool_type'] as Map<String, dynamic>)
          : null,
      parameters: (json['parameters'] as List?)
          ?.map((e) => ToolParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
      returns: json['returns'] != null
          ? ToolReturnType.fromJson(json['returns'] as Map<String, dynamic>)
          : null,
      returnTarget: json['return_target'] != null
          ? ToolReturnTarget.fromJson(json['return_target'] as Map<String, dynamic>)
          : null,
      required: json['required'] as bool?,
      owner: json['owner'] as String?,
      permissions: (json['permissions'] as List?)?.cast<String>(),
      timeoutS: json['timeout_s'] as int?,
      examples: (json['examples'] as List?)
          ?.map((e) => Map<String, dynamic>.fromJson(e as Map<String, dynamic>))
          .toList(),
      retry: json['retry'] != null
          ? RetryConfig.fromJson(json['retry'] as Map<String, dynamic>)
          : null,
      circuitBreaker: json['circuit_breaker'] != null
          ? CircuitBreakerConfig.fromJson(json['circuit_breaker'] as Map<String, dynamic>)
          : null,
      idempotency: json['idempotency'] != null
          ? IdempotencyConfig.fromJson(json['idempotency'] as Map<String, dynamic>)
          : null,
      idempotencyKeyGenerator: json['idempotency_key_generator'] as String?,
      circuitBreakerPolicy: json['circuit_breaker_policy'] as String?,
      retryPolicy: json['retry_policy'] as String?,
      metricsTags: json['metrics_tags'] != null
          ? Map<String, dynamic>.from(json['metrics_tags'])
          : null,
      interruption: json['interruption'] != null
          ? InterruptionConfig.fromJson(json['interruption'] as Map<String, dynamic>)
          : null,
      preToolSpeech: json['pre_tool_speech'] != null
          ? PreToolSpeechConfig.fromJson(json['pre_tool_speech'] as Map<String, dynamic>)
          : null,
      execution: json['execution'] != null
          ? ExecutionConfig.fromJson(json['execution'] as Map<String, dynamic>)
          : null,
      dynamicVariables: json['dynamic_variables'] != null
          ? DynamicVariableConfig.fromJson(json['dynamic_variables'] as Map<String, dynamic>)
          : null,
      driver: json['driver'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      if (id != null) 'id': id,
      if (version != null) 'version': version,
      if (toolName != null) 'tool_name': toolName,
      if (description != null) 'description': description,
      if (toolType != null) 'tool_type': toolType!.toJson(),
      if (parameters != null) 'parameters': parameters!.map((e) => e.toJson()).toList(),
      if (returns != null) 'returns': returns!.toJson(),
      if (returnTarget != null) 'return_target': returnTarget!.toJson(),
      if (required != null) 'required': required,
      if (owner != null) 'owner': owner,
      if (permissions != null) 'permissions': permissions,
      if (timeoutS != null) 'timeout_s': timeoutS,
      if (examples != null) 'examples': examples!.map((e) => e.toJson()).toList(),
      if (retry != null) 'retry': retry!.toJson(),
      if (circuitBreaker != null) 'circuit_breaker': circuitBreaker!.toJson(),
      if (idempotency != null) 'idempotency': idempotency!.toJson(),
      if (idempotencyKeyGenerator != null) 'idempotency_key_generator': idempotencyKeyGenerator,
      if (circuitBreakerPolicy != null) 'circuit_breaker_policy': circuitBreakerPolicy,
      if (retryPolicy != null) 'retry_policy': retryPolicy,
      if (metricsTags != null) 'metrics_tags': metricsTags,
      if (interruption != null) 'interruption': interruption!.toJson(),
      if (preToolSpeech != null) 'pre_tool_speech': preToolSpeech!.toJson(),
      if (execution != null) 'execution': execution!.toJson(),
      if (dynamicVariables != null) 'dynamic_variables': dynamicVariables!.toJson(),
      if (driver != null) 'driver': driver,
    };
  }

  DbToolSpec copyWith({
    String? id,
    String? version,
    String? toolName,
    String? description,
    ToolType? toolType,
    List<ToolParameter>? parameters,
    ToolReturnType? returns,
    ToolReturnTarget? returnTarget,
    bool? required,
    String? owner,
    List<String>? permissions,
    int? timeoutS,
    List<Map<String, dynamic>>? examples,
    RetryConfig? retry,
    CircuitBreakerConfig? circuitBreaker,
    IdempotencyConfig? idempotency,
    String? idempotencyKeyGenerator,
    String? circuitBreakerPolicy,
    String? retryPolicy,
    Map<String, String>? metricsTags,
    InterruptionConfig? interruption,
    PreToolSpeechConfig? preToolSpeech,
    ExecutionConfig? execution,
    DynamicVariableConfig? dynamicVariables,
    String? driver,
  }}) {
    return DbToolSpec(
      id: id ?? this.id,
      version: version ?? this.version,
      toolName: toolName ?? this.toolName,
      description: description ?? this.description,
      toolType: toolType ?? this.toolType,
      parameters: parameters ?? this.parameters,
      returns: returns ?? this.returns,
      returnTarget: returnTarget ?? this.returnTarget,
      required: required ?? this.required,
      owner: owner ?? this.owner,
      permissions: permissions ?? this.permissions,
      timeoutS: timeoutS ?? this.timeoutS,
      examples: examples ?? this.examples,
      retry: retry ?? this.retry,
      circuitBreaker: circuitBreaker ?? this.circuitBreaker,
      idempotency: idempotency ?? this.idempotency,
      idempotencyKeyGenerator: idempotencyKeyGenerator ?? this.idempotencyKeyGenerator,
      circuitBreakerPolicy: circuitBreakerPolicy ?? this.circuitBreakerPolicy,
      retryPolicy: retryPolicy ?? this.retryPolicy,
      metricsTags: metricsTags ?? this.metricsTags,
      interruption: interruption ?? this.interruption,
      preToolSpeech: preToolSpeech ?? this.preToolSpeech,
      execution: execution ?? this.execution,
      dynamicVariables: dynamicVariables ?? this.dynamicVariables,
      driver: driver ?? this.driver,
    );
  }

  factory DbToolSpec.empty() {
    return const DbToolSpec();
  }
}

class DynamoDbToolSpec {
  /// Tool ID
  /// Unique identifier for the tool (auto-generated from name)
  final String id;
  /// Version
  /// Tool version string (semver recommended)
  final String? version;
  /// Display Name
  /// Human-readable tool name
  final String toolName;
  /// Description
  /// Tool description (helps LLM understand when to use it)
  final String description;
  final ToolType? toolType;
  /// Parameters
  /// Input parameters for this tool
  final List<ToolParameter>? parameters;
  /// Return Type
  /// Format of tool output
  final ToolReturnType? returns;
  /// Return Target
  /// Where to route tool output
  final ToolReturnTarget? returnTarget;
  /// Required Tool
  /// Whether this tool must be available for the agent
  final bool? required;
  /// Owner
  /// Tool owner identifier
  final String? owner;
  /// Required Permissions
  /// Permissions required to use this tool
  final List<String>? permissions;
  /// Timeout (seconds)
  /// Maximum execution time before timeout
  final int? timeoutS;
  /// Usage Examples
  /// Example inputs/outputs for documentation
  final List<Map<String, dynamic>>? examples;
  /// Retry Configuration
  /// Configure automatic retry behavior
  final RetryConfig? retry;
  /// Circuit Breaker
  /// Configure circuit breaker pattern
  final CircuitBreakerConfig? circuitBreaker;
  /// Idempotency
  /// Configure idempotency behavior
  final IdempotencyConfig? idempotency;
  final String? idempotencyKeyGenerator;
  final String? circuitBreakerPolicy;
  final String? retryPolicy;
  /// Metrics Tags
  /// Static tags for metrics/observability
  final Map<String, String>? metricsTags;
  /// Interruption Control
  /// Controls whether user input can interrupt tool execution
  final InterruptionConfig? interruption;
  /// Pre-Tool Speech
  /// Configuration for what agent says before executing tool
  final PreToolSpeechConfig? preToolSpeech;
  /// Execution Mode
  /// Controls speech/execution timing
  final ExecutionConfig? execution;
  /// Dynamic Variables
  /// Configuration for updating variables based on tool results
  final DynamicVariableConfig? dynamicVariables;
  final String? driver;
  /// AWS Region
  /// AWS region for DynamoDB
  final String? region;
  /// Table Name
  /// DynamoDB table name
  final String tableName;
  /// Endpoint URL (Optional)
  /// Custom endpoint for LocalStack/testing
  final String? endpointUrl;
  /// AWS Access Key ID (Optional)
  /// Prefer IAM roles over hardcoded credentials
  final String? awsAccessKeyId;
  /// AWS Secret Access Key
  /// Prefer IAM roles over hardcoded credentials
  final String? awsSecretAccessKey;

  const DynamoDbToolSpec({
    required this.id,
    this.version,
    required this.toolName,
    required this.description,
    this.toolType,
    this.parameters,
    this.returns,
    this.returnTarget,
    this.required,
    this.owner,
    this.permissions,
    this.timeoutS,
    this.examples,
    this.retry,
    this.circuitBreaker,
    this.idempotency,
    this.idempotencyKeyGenerator,
    this.circuitBreakerPolicy,
    this.retryPolicy,
    this.metricsTags,
    this.interruption,
    this.preToolSpeech,
    this.execution,
    this.dynamicVariables,
    this.driver,
    this.region,
    required this.tableName,
    this.endpointUrl,
    this.awsAccessKeyId,
    this.awsSecretAccessKey,
  });

  factory DynamoDbToolSpec.fromJson(Map<String, dynamic> json) {
    return DynamoDbToolSpec(
      id: json['id'] as String?,
      version: json['version'] as String?,
      toolName: json['tool_name'] as String?,
      description: json['description'] as String?,
      toolType: json['tool_type'] != null
          ? ToolType.fromJson(json['tool_type'] as Map<String, dynamic>)
          : null,
      parameters: (json['parameters'] as List?)
          ?.map((e) => ToolParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
      returns: json['returns'] != null
          ? ToolReturnType.fromJson(json['returns'] as Map<String, dynamic>)
          : null,
      returnTarget: json['return_target'] != null
          ? ToolReturnTarget.fromJson(json['return_target'] as Map<String, dynamic>)
          : null,
      required: json['required'] as bool?,
      owner: json['owner'] as String?,
      permissions: (json['permissions'] as List?)?.cast<String>(),
      timeoutS: json['timeout_s'] as int?,
      examples: (json['examples'] as List?)
          ?.map((e) => Map<String, dynamic>.fromJson(e as Map<String, dynamic>))
          .toList(),
      retry: json['retry'] != null
          ? RetryConfig.fromJson(json['retry'] as Map<String, dynamic>)
          : null,
      circuitBreaker: json['circuit_breaker'] != null
          ? CircuitBreakerConfig.fromJson(json['circuit_breaker'] as Map<String, dynamic>)
          : null,
      idempotency: json['idempotency'] != null
          ? IdempotencyConfig.fromJson(json['idempotency'] as Map<String, dynamic>)
          : null,
      idempotencyKeyGenerator: json['idempotency_key_generator'] as String?,
      circuitBreakerPolicy: json['circuit_breaker_policy'] as String?,
      retryPolicy: json['retry_policy'] as String?,
      metricsTags: json['metrics_tags'] != null
          ? Map<String, dynamic>.from(json['metrics_tags'])
          : null,
      interruption: json['interruption'] != null
          ? InterruptionConfig.fromJson(json['interruption'] as Map<String, dynamic>)
          : null,
      preToolSpeech: json['pre_tool_speech'] != null
          ? PreToolSpeechConfig.fromJson(json['pre_tool_speech'] as Map<String, dynamic>)
          : null,
      execution: json['execution'] != null
          ? ExecutionConfig.fromJson(json['execution'] as Map<String, dynamic>)
          : null,
      dynamicVariables: json['dynamic_variables'] != null
          ? DynamicVariableConfig.fromJson(json['dynamic_variables'] as Map<String, dynamic>)
          : null,
      driver: json['driver'] as String?,
      region: json['region'] as String?,
      tableName: json['table_name'] as String?,
      endpointUrl: json['endpoint_url'] as String?,
      awsAccessKeyId: json['aws_access_key_id'] as String?,
      awsSecretAccessKey: json['aws_secret_access_key'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      if (id != null) 'id': id,
      if (version != null) 'version': version,
      if (toolName != null) 'tool_name': toolName,
      if (description != null) 'description': description,
      if (toolType != null) 'tool_type': toolType!.toJson(),
      if (parameters != null) 'parameters': parameters!.map((e) => e.toJson()).toList(),
      if (returns != null) 'returns': returns!.toJson(),
      if (returnTarget != null) 'return_target': returnTarget!.toJson(),
      if (required != null) 'required': required,
      if (owner != null) 'owner': owner,
      if (permissions != null) 'permissions': permissions,
      if (timeoutS != null) 'timeout_s': timeoutS,
      if (examples != null) 'examples': examples!.map((e) => e.toJson()).toList(),
      if (retry != null) 'retry': retry!.toJson(),
      if (circuitBreaker != null) 'circuit_breaker': circuitBreaker!.toJson(),
      if (idempotency != null) 'idempotency': idempotency!.toJson(),
      if (idempotencyKeyGenerator != null) 'idempotency_key_generator': idempotencyKeyGenerator,
      if (circuitBreakerPolicy != null) 'circuit_breaker_policy': circuitBreakerPolicy,
      if (retryPolicy != null) 'retry_policy': retryPolicy,
      if (metricsTags != null) 'metrics_tags': metricsTags,
      if (interruption != null) 'interruption': interruption!.toJson(),
      if (preToolSpeech != null) 'pre_tool_speech': preToolSpeech!.toJson(),
      if (execution != null) 'execution': execution!.toJson(),
      if (dynamicVariables != null) 'dynamic_variables': dynamicVariables!.toJson(),
      if (driver != null) 'driver': driver,
      if (region != null) 'region': region,
      if (tableName != null) 'table_name': tableName,
      if (endpointUrl != null) 'endpoint_url': endpointUrl,
      if (awsAccessKeyId != null) 'aws_access_key_id': awsAccessKeyId,
      if (awsSecretAccessKey != null) 'aws_secret_access_key': awsSecretAccessKey,
    };
  }

  DynamoDbToolSpec copyWith({
    String? id,
    String? version,
    String? toolName,
    String? description,
    ToolType? toolType,
    List<ToolParameter>? parameters,
    ToolReturnType? returns,
    ToolReturnTarget? returnTarget,
    bool? required,
    String? owner,
    List<String>? permissions,
    int? timeoutS,
    List<Map<String, dynamic>>? examples,
    RetryConfig? retry,
    CircuitBreakerConfig? circuitBreaker,
    IdempotencyConfig? idempotency,
    String? idempotencyKeyGenerator,
    String? circuitBreakerPolicy,
    String? retryPolicy,
    Map<String, String>? metricsTags,
    InterruptionConfig? interruption,
    PreToolSpeechConfig? preToolSpeech,
    ExecutionConfig? execution,
    DynamicVariableConfig? dynamicVariables,
    String? driver,
    String? region,
    String? tableName,
    String? endpointUrl,
    String? awsAccessKeyId,
    String? awsSecretAccessKey,
  }}) {
    return DynamoDbToolSpec(
      id: id ?? this.id,
      version: version ?? this.version,
      toolName: toolName ?? this.toolName,
      description: description ?? this.description,
      toolType: toolType ?? this.toolType,
      parameters: parameters ?? this.parameters,
      returns: returns ?? this.returns,
      returnTarget: returnTarget ?? this.returnTarget,
      required: required ?? this.required,
      owner: owner ?? this.owner,
      permissions: permissions ?? this.permissions,
      timeoutS: timeoutS ?? this.timeoutS,
      examples: examples ?? this.examples,
      retry: retry ?? this.retry,
      circuitBreaker: circuitBreaker ?? this.circuitBreaker,
      idempotency: idempotency ?? this.idempotency,
      idempotencyKeyGenerator: idempotencyKeyGenerator ?? this.idempotencyKeyGenerator,
      circuitBreakerPolicy: circuitBreakerPolicy ?? this.circuitBreakerPolicy,
      retryPolicy: retryPolicy ?? this.retryPolicy,
      metricsTags: metricsTags ?? this.metricsTags,
      interruption: interruption ?? this.interruption,
      preToolSpeech: preToolSpeech ?? this.preToolSpeech,
      execution: execution ?? this.execution,
      dynamicVariables: dynamicVariables ?? this.dynamicVariables,
      driver: driver ?? this.driver,
      region: region ?? this.region,
      tableName: tableName ?? this.tableName,
      endpointUrl: endpointUrl ?? this.endpointUrl,
      awsAccessKeyId: awsAccessKeyId ?? this.awsAccessKeyId,
      awsSecretAccessKey: awsSecretAccessKey ?? this.awsSecretAccessKey,
    );
  }

  factory DynamoDbToolSpec.empty() {
    return const DynamoDbToolSpec();
  }
}

class PostgreSqlToolSpec {
  /// Tool ID
  /// Unique identifier for the tool (auto-generated from name)
  final String id;
  /// Version
  /// Tool version string (semver recommended)
  final String? version;
  /// Display Name
  /// Human-readable tool name
  final String toolName;
  /// Description
  /// Tool description (helps LLM understand when to use it)
  final String description;
  final ToolType? toolType;
  /// Parameters
  /// Input parameters for this tool
  final List<ToolParameter>? parameters;
  /// Return Type
  /// Format of tool output
  final ToolReturnType? returns;
  /// Return Target
  /// Where to route tool output
  final ToolReturnTarget? returnTarget;
  /// Required Tool
  /// Whether this tool must be available for the agent
  final bool? required;
  /// Owner
  /// Tool owner identifier
  final String? owner;
  /// Required Permissions
  /// Permissions required to use this tool
  final List<String>? permissions;
  /// Timeout (seconds)
  /// Maximum execution time before timeout
  final int? timeoutS;
  /// Usage Examples
  /// Example inputs/outputs for documentation
  final List<Map<String, dynamic>>? examples;
  /// Retry Configuration
  /// Configure automatic retry behavior
  final RetryConfig? retry;
  /// Circuit Breaker
  /// Configure circuit breaker pattern
  final CircuitBreakerConfig? circuitBreaker;
  /// Idempotency
  /// Configure idempotency behavior
  final IdempotencyConfig? idempotency;
  final String? idempotencyKeyGenerator;
  final String? circuitBreakerPolicy;
  final String? retryPolicy;
  /// Metrics Tags
  /// Static tags for metrics/observability
  final Map<String, String>? metricsTags;
  /// Interruption Control
  /// Controls whether user input can interrupt tool execution
  final InterruptionConfig? interruption;
  /// Pre-Tool Speech
  /// Configuration for what agent says before executing tool
  final PreToolSpeechConfig? preToolSpeech;
  /// Execution Mode
  /// Controls speech/execution timing
  final ExecutionConfig? execution;
  /// Dynamic Variables
  /// Configuration for updating variables based on tool results
  final DynamicVariableConfig? dynamicVariables;
  final String? driver;
  /// Host
  /// Database host
  final String? host;
  /// Port
  /// Database port (default: 5432)
  final int? port;
  /// Database Name
  /// Database name
  final String database;
  /// Username
  /// Database username
  final String username;
  /// Password
  /// Database password
  final String password;
  /// Connection String (Optional)
  /// Full connection string (overrides individual fields)
  final String? connectionString;
  /// SSL Mode
  /// SSL connection mode
  final String? sslMode;
  /// Pool Size
  /// Connection pool size
  final int? poolSize;

  const PostgreSqlToolSpec({
    required this.id,
    this.version,
    required this.toolName,
    required this.description,
    this.toolType,
    this.parameters,
    this.returns,
    this.returnTarget,
    this.required,
    this.owner,
    this.permissions,
    this.timeoutS,
    this.examples,
    this.retry,
    this.circuitBreaker,
    this.idempotency,
    this.idempotencyKeyGenerator,
    this.circuitBreakerPolicy,
    this.retryPolicy,
    this.metricsTags,
    this.interruption,
    this.preToolSpeech,
    this.execution,
    this.dynamicVariables,
    this.driver,
    this.host,
    this.port,
    required this.database,
    required this.username,
    required this.password,
    this.connectionString,
    this.sslMode,
    this.poolSize,
  });

  factory PostgreSqlToolSpec.fromJson(Map<String, dynamic> json) {
    return PostgreSqlToolSpec(
      id: json['id'] as String?,
      version: json['version'] as String?,
      toolName: json['tool_name'] as String?,
      description: json['description'] as String?,
      toolType: json['tool_type'] != null
          ? ToolType.fromJson(json['tool_type'] as Map<String, dynamic>)
          : null,
      parameters: (json['parameters'] as List?)
          ?.map((e) => ToolParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
      returns: json['returns'] != null
          ? ToolReturnType.fromJson(json['returns'] as Map<String, dynamic>)
          : null,
      returnTarget: json['return_target'] != null
          ? ToolReturnTarget.fromJson(json['return_target'] as Map<String, dynamic>)
          : null,
      required: json['required'] as bool?,
      owner: json['owner'] as String?,
      permissions: (json['permissions'] as List?)?.cast<String>(),
      timeoutS: json['timeout_s'] as int?,
      examples: (json['examples'] as List?)
          ?.map((e) => Map<String, dynamic>.fromJson(e as Map<String, dynamic>))
          .toList(),
      retry: json['retry'] != null
          ? RetryConfig.fromJson(json['retry'] as Map<String, dynamic>)
          : null,
      circuitBreaker: json['circuit_breaker'] != null
          ? CircuitBreakerConfig.fromJson(json['circuit_breaker'] as Map<String, dynamic>)
          : null,
      idempotency: json['idempotency'] != null
          ? IdempotencyConfig.fromJson(json['idempotency'] as Map<String, dynamic>)
          : null,
      idempotencyKeyGenerator: json['idempotency_key_generator'] as String?,
      circuitBreakerPolicy: json['circuit_breaker_policy'] as String?,
      retryPolicy: json['retry_policy'] as String?,
      metricsTags: json['metrics_tags'] != null
          ? Map<String, dynamic>.from(json['metrics_tags'])
          : null,
      interruption: json['interruption'] != null
          ? InterruptionConfig.fromJson(json['interruption'] as Map<String, dynamic>)
          : null,
      preToolSpeech: json['pre_tool_speech'] != null
          ? PreToolSpeechConfig.fromJson(json['pre_tool_speech'] as Map<String, dynamic>)
          : null,
      execution: json['execution'] != null
          ? ExecutionConfig.fromJson(json['execution'] as Map<String, dynamic>)
          : null,
      dynamicVariables: json['dynamic_variables'] != null
          ? DynamicVariableConfig.fromJson(json['dynamic_variables'] as Map<String, dynamic>)
          : null,
      driver: json['driver'] as String?,
      host: json['host'] as String?,
      port: json['port'] as int?,
      database: json['database'] as String?,
      username: json['username'] as String?,
      password: json['password'] as String?,
      connectionString: json['connection_string'] as String?,
      sslMode: json['ssl_mode'] as String?,
      poolSize: json['pool_size'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      if (id != null) 'id': id,
      if (version != null) 'version': version,
      if (toolName != null) 'tool_name': toolName,
      if (description != null) 'description': description,
      if (toolType != null) 'tool_type': toolType!.toJson(),
      if (parameters != null) 'parameters': parameters!.map((e) => e.toJson()).toList(),
      if (returns != null) 'returns': returns!.toJson(),
      if (returnTarget != null) 'return_target': returnTarget!.toJson(),
      if (required != null) 'required': required,
      if (owner != null) 'owner': owner,
      if (permissions != null) 'permissions': permissions,
      if (timeoutS != null) 'timeout_s': timeoutS,
      if (examples != null) 'examples': examples!.map((e) => e.toJson()).toList(),
      if (retry != null) 'retry': retry!.toJson(),
      if (circuitBreaker != null) 'circuit_breaker': circuitBreaker!.toJson(),
      if (idempotency != null) 'idempotency': idempotency!.toJson(),
      if (idempotencyKeyGenerator != null) 'idempotency_key_generator': idempotencyKeyGenerator,
      if (circuitBreakerPolicy != null) 'circuit_breaker_policy': circuitBreakerPolicy,
      if (retryPolicy != null) 'retry_policy': retryPolicy,
      if (metricsTags != null) 'metrics_tags': metricsTags,
      if (interruption != null) 'interruption': interruption!.toJson(),
      if (preToolSpeech != null) 'pre_tool_speech': preToolSpeech!.toJson(),
      if (execution != null) 'execution': execution!.toJson(),
      if (dynamicVariables != null) 'dynamic_variables': dynamicVariables!.toJson(),
      if (driver != null) 'driver': driver,
      if (host != null) 'host': host,
      if (port != null) 'port': port,
      if (database != null) 'database': database,
      if (username != null) 'username': username,
      if (password != null) 'password': password,
      if (connectionString != null) 'connection_string': connectionString,
      if (sslMode != null) 'ssl_mode': sslMode,
      if (poolSize != null) 'pool_size': poolSize,
    };
  }

  PostgreSqlToolSpec copyWith({
    String? id,
    String? version,
    String? toolName,
    String? description,
    ToolType? toolType,
    List<ToolParameter>? parameters,
    ToolReturnType? returns,
    ToolReturnTarget? returnTarget,
    bool? required,
    String? owner,
    List<String>? permissions,
    int? timeoutS,
    List<Map<String, dynamic>>? examples,
    RetryConfig? retry,
    CircuitBreakerConfig? circuitBreaker,
    IdempotencyConfig? idempotency,
    String? idempotencyKeyGenerator,
    String? circuitBreakerPolicy,
    String? retryPolicy,
    Map<String, String>? metricsTags,
    InterruptionConfig? interruption,
    PreToolSpeechConfig? preToolSpeech,
    ExecutionConfig? execution,
    DynamicVariableConfig? dynamicVariables,
    String? driver,
    String? host,
    int? port,
    String? database,
    String? username,
    String? password,
    String? connectionString,
    String? sslMode,
    int? poolSize,
  }}) {
    return PostgreSqlToolSpec(
      id: id ?? this.id,
      version: version ?? this.version,
      toolName: toolName ?? this.toolName,
      description: description ?? this.description,
      toolType: toolType ?? this.toolType,
      parameters: parameters ?? this.parameters,
      returns: returns ?? this.returns,
      returnTarget: returnTarget ?? this.returnTarget,
      required: required ?? this.required,
      owner: owner ?? this.owner,
      permissions: permissions ?? this.permissions,
      timeoutS: timeoutS ?? this.timeoutS,
      examples: examples ?? this.examples,
      retry: retry ?? this.retry,
      circuitBreaker: circuitBreaker ?? this.circuitBreaker,
      idempotency: idempotency ?? this.idempotency,
      idempotencyKeyGenerator: idempotencyKeyGenerator ?? this.idempotencyKeyGenerator,
      circuitBreakerPolicy: circuitBreakerPolicy ?? this.circuitBreakerPolicy,
      retryPolicy: retryPolicy ?? this.retryPolicy,
      metricsTags: metricsTags ?? this.metricsTags,
      interruption: interruption ?? this.interruption,
      preToolSpeech: preToolSpeech ?? this.preToolSpeech,
      execution: execution ?? this.execution,
      dynamicVariables: dynamicVariables ?? this.dynamicVariables,
      driver: driver ?? this.driver,
      host: host ?? this.host,
      port: port ?? this.port,
      database: database ?? this.database,
      username: username ?? this.username,
      password: password ?? this.password,
      connectionString: connectionString ?? this.connectionString,
      sslMode: sslMode ?? this.sslMode,
      poolSize: poolSize ?? this.poolSize,
    );
  }

  factory PostgreSqlToolSpec.empty() {
    return const PostgreSqlToolSpec();
  }
}

class MySqlToolSpec {
  /// Tool ID
  /// Unique identifier for the tool (auto-generated from name)
  final String id;
  /// Version
  /// Tool version string (semver recommended)
  final String? version;
  /// Display Name
  /// Human-readable tool name
  final String toolName;
  /// Description
  /// Tool description (helps LLM understand when to use it)
  final String description;
  final ToolType? toolType;
  /// Parameters
  /// Input parameters for this tool
  final List<ToolParameter>? parameters;
  /// Return Type
  /// Format of tool output
  final ToolReturnType? returns;
  /// Return Target
  /// Where to route tool output
  final ToolReturnTarget? returnTarget;
  /// Required Tool
  /// Whether this tool must be available for the agent
  final bool? required;
  /// Owner
  /// Tool owner identifier
  final String? owner;
  /// Required Permissions
  /// Permissions required to use this tool
  final List<String>? permissions;
  /// Timeout (seconds)
  /// Maximum execution time before timeout
  final int? timeoutS;
  /// Usage Examples
  /// Example inputs/outputs for documentation
  final List<Map<String, dynamic>>? examples;
  /// Retry Configuration
  /// Configure automatic retry behavior
  final RetryConfig? retry;
  /// Circuit Breaker
  /// Configure circuit breaker pattern
  final CircuitBreakerConfig? circuitBreaker;
  /// Idempotency
  /// Configure idempotency behavior
  final IdempotencyConfig? idempotency;
  final String? idempotencyKeyGenerator;
  final String? circuitBreakerPolicy;
  final String? retryPolicy;
  /// Metrics Tags
  /// Static tags for metrics/observability
  final Map<String, String>? metricsTags;
  /// Interruption Control
  /// Controls whether user input can interrupt tool execution
  final InterruptionConfig? interruption;
  /// Pre-Tool Speech
  /// Configuration for what agent says before executing tool
  final PreToolSpeechConfig? preToolSpeech;
  /// Execution Mode
  /// Controls speech/execution timing
  final ExecutionConfig? execution;
  /// Dynamic Variables
  /// Configuration for updating variables based on tool results
  final DynamicVariableConfig? dynamicVariables;
  final String? driver;
  /// Host
  /// Database host
  final String? host;
  /// Port
  /// Database port (default: 3306)
  final int? port;
  /// Database Name
  /// Database name
  final String database;
  /// Username
  /// Database username
  final String username;
  /// Password
  /// Database password
  final String password;
  /// Connection String (Optional)
  /// Full connection string (overrides individual fields)
  final String? connectionString;
  /// Charset
  /// Character set
  final String? charset;

  const MySqlToolSpec({
    required this.id,
    this.version,
    required this.toolName,
    required this.description,
    this.toolType,
    this.parameters,
    this.returns,
    this.returnTarget,
    this.required,
    this.owner,
    this.permissions,
    this.timeoutS,
    this.examples,
    this.retry,
    this.circuitBreaker,
    this.idempotency,
    this.idempotencyKeyGenerator,
    this.circuitBreakerPolicy,
    this.retryPolicy,
    this.metricsTags,
    this.interruption,
    this.preToolSpeech,
    this.execution,
    this.dynamicVariables,
    this.driver,
    this.host,
    this.port,
    required this.database,
    required this.username,
    required this.password,
    this.connectionString,
    this.charset,
  });

  factory MySqlToolSpec.fromJson(Map<String, dynamic> json) {
    return MySqlToolSpec(
      id: json['id'] as String?,
      version: json['version'] as String?,
      toolName: json['tool_name'] as String?,
      description: json['description'] as String?,
      toolType: json['tool_type'] != null
          ? ToolType.fromJson(json['tool_type'] as Map<String, dynamic>)
          : null,
      parameters: (json['parameters'] as List?)
          ?.map((e) => ToolParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
      returns: json['returns'] != null
          ? ToolReturnType.fromJson(json['returns'] as Map<String, dynamic>)
          : null,
      returnTarget: json['return_target'] != null
          ? ToolReturnTarget.fromJson(json['return_target'] as Map<String, dynamic>)
          : null,
      required: json['required'] as bool?,
      owner: json['owner'] as String?,
      permissions: (json['permissions'] as List?)?.cast<String>(),
      timeoutS: json['timeout_s'] as int?,
      examples: (json['examples'] as List?)
          ?.map((e) => Map<String, dynamic>.fromJson(e as Map<String, dynamic>))
          .toList(),
      retry: json['retry'] != null
          ? RetryConfig.fromJson(json['retry'] as Map<String, dynamic>)
          : null,
      circuitBreaker: json['circuit_breaker'] != null
          ? CircuitBreakerConfig.fromJson(json['circuit_breaker'] as Map<String, dynamic>)
          : null,
      idempotency: json['idempotency'] != null
          ? IdempotencyConfig.fromJson(json['idempotency'] as Map<String, dynamic>)
          : null,
      idempotencyKeyGenerator: json['idempotency_key_generator'] as String?,
      circuitBreakerPolicy: json['circuit_breaker_policy'] as String?,
      retryPolicy: json['retry_policy'] as String?,
      metricsTags: json['metrics_tags'] != null
          ? Map<String, dynamic>.from(json['metrics_tags'])
          : null,
      interruption: json['interruption'] != null
          ? InterruptionConfig.fromJson(json['interruption'] as Map<String, dynamic>)
          : null,
      preToolSpeech: json['pre_tool_speech'] != null
          ? PreToolSpeechConfig.fromJson(json['pre_tool_speech'] as Map<String, dynamic>)
          : null,
      execution: json['execution'] != null
          ? ExecutionConfig.fromJson(json['execution'] as Map<String, dynamic>)
          : null,
      dynamicVariables: json['dynamic_variables'] != null
          ? DynamicVariableConfig.fromJson(json['dynamic_variables'] as Map<String, dynamic>)
          : null,
      driver: json['driver'] as String?,
      host: json['host'] as String?,
      port: json['port'] as int?,
      database: json['database'] as String?,
      username: json['username'] as String?,
      password: json['password'] as String?,
      connectionString: json['connection_string'] as String?,
      charset: json['charset'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      if (id != null) 'id': id,
      if (version != null) 'version': version,
      if (toolName != null) 'tool_name': toolName,
      if (description != null) 'description': description,
      if (toolType != null) 'tool_type': toolType!.toJson(),
      if (parameters != null) 'parameters': parameters!.map((e) => e.toJson()).toList(),
      if (returns != null) 'returns': returns!.toJson(),
      if (returnTarget != null) 'return_target': returnTarget!.toJson(),
      if (required != null) 'required': required,
      if (owner != null) 'owner': owner,
      if (permissions != null) 'permissions': permissions,
      if (timeoutS != null) 'timeout_s': timeoutS,
      if (examples != null) 'examples': examples!.map((e) => e.toJson()).toList(),
      if (retry != null) 'retry': retry!.toJson(),
      if (circuitBreaker != null) 'circuit_breaker': circuitBreaker!.toJson(),
      if (idempotency != null) 'idempotency': idempotency!.toJson(),
      if (idempotencyKeyGenerator != null) 'idempotency_key_generator': idempotencyKeyGenerator,
      if (circuitBreakerPolicy != null) 'circuit_breaker_policy': circuitBreakerPolicy,
      if (retryPolicy != null) 'retry_policy': retryPolicy,
      if (metricsTags != null) 'metrics_tags': metricsTags,
      if (interruption != null) 'interruption': interruption!.toJson(),
      if (preToolSpeech != null) 'pre_tool_speech': preToolSpeech!.toJson(),
      if (execution != null) 'execution': execution!.toJson(),
      if (dynamicVariables != null) 'dynamic_variables': dynamicVariables!.toJson(),
      if (driver != null) 'driver': driver,
      if (host != null) 'host': host,
      if (port != null) 'port': port,
      if (database != null) 'database': database,
      if (username != null) 'username': username,
      if (password != null) 'password': password,
      if (connectionString != null) 'connection_string': connectionString,
      if (charset != null) 'charset': charset,
    };
  }

  MySqlToolSpec copyWith({
    String? id,
    String? version,
    String? toolName,
    String? description,
    ToolType? toolType,
    List<ToolParameter>? parameters,
    ToolReturnType? returns,
    ToolReturnTarget? returnTarget,
    bool? required,
    String? owner,
    List<String>? permissions,
    int? timeoutS,
    List<Map<String, dynamic>>? examples,
    RetryConfig? retry,
    CircuitBreakerConfig? circuitBreaker,
    IdempotencyConfig? idempotency,
    String? idempotencyKeyGenerator,
    String? circuitBreakerPolicy,
    String? retryPolicy,
    Map<String, String>? metricsTags,
    InterruptionConfig? interruption,
    PreToolSpeechConfig? preToolSpeech,
    ExecutionConfig? execution,
    DynamicVariableConfig? dynamicVariables,
    String? driver,
    String? host,
    int? port,
    String? database,
    String? username,
    String? password,
    String? connectionString,
    String? charset,
  }}) {
    return MySqlToolSpec(
      id: id ?? this.id,
      version: version ?? this.version,
      toolName: toolName ?? this.toolName,
      description: description ?? this.description,
      toolType: toolType ?? this.toolType,
      parameters: parameters ?? this.parameters,
      returns: returns ?? this.returns,
      returnTarget: returnTarget ?? this.returnTarget,
      required: required ?? this.required,
      owner: owner ?? this.owner,
      permissions: permissions ?? this.permissions,
      timeoutS: timeoutS ?? this.timeoutS,
      examples: examples ?? this.examples,
      retry: retry ?? this.retry,
      circuitBreaker: circuitBreaker ?? this.circuitBreaker,
      idempotency: idempotency ?? this.idempotency,
      idempotencyKeyGenerator: idempotencyKeyGenerator ?? this.idempotencyKeyGenerator,
      circuitBreakerPolicy: circuitBreakerPolicy ?? this.circuitBreakerPolicy,
      retryPolicy: retryPolicy ?? this.retryPolicy,
      metricsTags: metricsTags ?? this.metricsTags,
      interruption: interruption ?? this.interruption,
      preToolSpeech: preToolSpeech ?? this.preToolSpeech,
      execution: execution ?? this.execution,
      dynamicVariables: dynamicVariables ?? this.dynamicVariables,
      driver: driver ?? this.driver,
      host: host ?? this.host,
      port: port ?? this.port,
      database: database ?? this.database,
      username: username ?? this.username,
      password: password ?? this.password,
      connectionString: connectionString ?? this.connectionString,
      charset: charset ?? this.charset,
    );
  }

  factory MySqlToolSpec.empty() {
    return const MySqlToolSpec();
  }
}

class SqliteToolSpec {
  /// Tool ID
  /// Unique identifier for the tool (auto-generated from name)
  final String id;
  /// Version
  /// Tool version string (semver recommended)
  final String? version;
  /// Display Name
  /// Human-readable tool name
  final String toolName;
  /// Description
  /// Tool description (helps LLM understand when to use it)
  final String description;
  final ToolType? toolType;
  /// Parameters
  /// Input parameters for this tool
  final List<ToolParameter>? parameters;
  /// Return Type
  /// Format of tool output
  final ToolReturnType? returns;
  /// Return Target
  /// Where to route tool output
  final ToolReturnTarget? returnTarget;
  /// Required Tool
  /// Whether this tool must be available for the agent
  final bool? required;
  /// Owner
  /// Tool owner identifier
  final String? owner;
  /// Required Permissions
  /// Permissions required to use this tool
  final List<String>? permissions;
  /// Timeout (seconds)
  /// Maximum execution time before timeout
  final int? timeoutS;
  /// Usage Examples
  /// Example inputs/outputs for documentation
  final List<Map<String, dynamic>>? examples;
  /// Retry Configuration
  /// Configure automatic retry behavior
  final RetryConfig? retry;
  /// Circuit Breaker
  /// Configure circuit breaker pattern
  final CircuitBreakerConfig? circuitBreaker;
  /// Idempotency
  /// Configure idempotency behavior
  final IdempotencyConfig? idempotency;
  final String? idempotencyKeyGenerator;
  final String? circuitBreakerPolicy;
  final String? retryPolicy;
  /// Metrics Tags
  /// Static tags for metrics/observability
  final Map<String, String>? metricsTags;
  /// Interruption Control
  /// Controls whether user input can interrupt tool execution
  final InterruptionConfig? interruption;
  /// Pre-Tool Speech
  /// Configuration for what agent says before executing tool
  final PreToolSpeechConfig? preToolSpeech;
  /// Execution Mode
  /// Controls speech/execution timing
  final ExecutionConfig? execution;
  /// Dynamic Variables
  /// Configuration for updating variables based on tool results
  final DynamicVariableConfig? dynamicVariables;
  final String? driver;
  /// Database Path
  /// Path to SQLite database file (:memory: for in-memory)
  final String? databasePath;
  /// Connection Timeout
  /// Connection timeout in seconds
  final double? timeout;
  /// Check Same Thread
  /// Enable thread safety check (disable for async)
  final bool? checkSameThread;

  const SqliteToolSpec({
    required this.id,
    this.version,
    required this.toolName,
    required this.description,
    this.toolType,
    this.parameters,
    this.returns,
    this.returnTarget,
    this.required,
    this.owner,
    this.permissions,
    this.timeoutS,
    this.examples,
    this.retry,
    this.circuitBreaker,
    this.idempotency,
    this.idempotencyKeyGenerator,
    this.circuitBreakerPolicy,
    this.retryPolicy,
    this.metricsTags,
    this.interruption,
    this.preToolSpeech,
    this.execution,
    this.dynamicVariables,
    this.driver,
    this.databasePath,
    this.timeout,
    this.checkSameThread,
  });

  factory SqliteToolSpec.fromJson(Map<String, dynamic> json) {
    return SqliteToolSpec(
      id: json['id'] as String?,
      version: json['version'] as String?,
      toolName: json['tool_name'] as String?,
      description: json['description'] as String?,
      toolType: json['tool_type'] != null
          ? ToolType.fromJson(json['tool_type'] as Map<String, dynamic>)
          : null,
      parameters: (json['parameters'] as List?)
          ?.map((e) => ToolParameter.fromJson(e as Map<String, dynamic>))
          .toList(),
      returns: json['returns'] != null
          ? ToolReturnType.fromJson(json['returns'] as Map<String, dynamic>)
          : null,
      returnTarget: json['return_target'] != null
          ? ToolReturnTarget.fromJson(json['return_target'] as Map<String, dynamic>)
          : null,
      required: json['required'] as bool?,
      owner: json['owner'] as String?,
      permissions: (json['permissions'] as List?)?.cast<String>(),
      timeoutS: json['timeout_s'] as int?,
      examples: (json['examples'] as List?)
          ?.map((e) => Map<String, dynamic>.fromJson(e as Map<String, dynamic>))
          .toList(),
      retry: json['retry'] != null
          ? RetryConfig.fromJson(json['retry'] as Map<String, dynamic>)
          : null,
      circuitBreaker: json['circuit_breaker'] != null
          ? CircuitBreakerConfig.fromJson(json['circuit_breaker'] as Map<String, dynamic>)
          : null,
      idempotency: json['idempotency'] != null
          ? IdempotencyConfig.fromJson(json['idempotency'] as Map<String, dynamic>)
          : null,
      idempotencyKeyGenerator: json['idempotency_key_generator'] as String?,
      circuitBreakerPolicy: json['circuit_breaker_policy'] as String?,
      retryPolicy: json['retry_policy'] as String?,
      metricsTags: json['metrics_tags'] != null
          ? Map<String, dynamic>.from(json['metrics_tags'])
          : null,
      interruption: json['interruption'] != null
          ? InterruptionConfig.fromJson(json['interruption'] as Map<String, dynamic>)
          : null,
      preToolSpeech: json['pre_tool_speech'] != null
          ? PreToolSpeechConfig.fromJson(json['pre_tool_speech'] as Map<String, dynamic>)
          : null,
      execution: json['execution'] != null
          ? ExecutionConfig.fromJson(json['execution'] as Map<String, dynamic>)
          : null,
      dynamicVariables: json['dynamic_variables'] != null
          ? DynamicVariableConfig.fromJson(json['dynamic_variables'] as Map<String, dynamic>)
          : null,
      driver: json['driver'] as String?,
      databasePath: json['database_path'] as String?,
      timeout: (json['timeout'] as num?)?.toDouble(),
      checkSameThread: json['check_same_thread'] as bool?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      if (id != null) 'id': id,
      if (version != null) 'version': version,
      if (toolName != null) 'tool_name': toolName,
      if (description != null) 'description': description,
      if (toolType != null) 'tool_type': toolType!.toJson(),
      if (parameters != null) 'parameters': parameters!.map((e) => e.toJson()).toList(),
      if (returns != null) 'returns': returns!.toJson(),
      if (returnTarget != null) 'return_target': returnTarget!.toJson(),
      if (required != null) 'required': required,
      if (owner != null) 'owner': owner,
      if (permissions != null) 'permissions': permissions,
      if (timeoutS != null) 'timeout_s': timeoutS,
      if (examples != null) 'examples': examples!.map((e) => e.toJson()).toList(),
      if (retry != null) 'retry': retry!.toJson(),
      if (circuitBreaker != null) 'circuit_breaker': circuitBreaker!.toJson(),
      if (idempotency != null) 'idempotency': idempotency!.toJson(),
      if (idempotencyKeyGenerator != null) 'idempotency_key_generator': idempotencyKeyGenerator,
      if (circuitBreakerPolicy != null) 'circuit_breaker_policy': circuitBreakerPolicy,
      if (retryPolicy != null) 'retry_policy': retryPolicy,
      if (metricsTags != null) 'metrics_tags': metricsTags,
      if (interruption != null) 'interruption': interruption!.toJson(),
      if (preToolSpeech != null) 'pre_tool_speech': preToolSpeech!.toJson(),
      if (execution != null) 'execution': execution!.toJson(),
      if (dynamicVariables != null) 'dynamic_variables': dynamicVariables!.toJson(),
      if (driver != null) 'driver': driver,
      if (databasePath != null) 'database_path': databasePath,
      if (timeout != null) 'timeout': timeout,
      if (checkSameThread != null) 'check_same_thread': checkSameThread,
    };
  }

  SqliteToolSpec copyWith({
    String? id,
    String? version,
    String? toolName,
    String? description,
    ToolType? toolType,
    List<ToolParameter>? parameters,
    ToolReturnType? returns,
    ToolReturnTarget? returnTarget,
    bool? required,
    String? owner,
    List<String>? permissions,
    int? timeoutS,
    List<Map<String, dynamic>>? examples,
    RetryConfig? retry,
    CircuitBreakerConfig? circuitBreaker,
    IdempotencyConfig? idempotency,
    String? idempotencyKeyGenerator,
    String? circuitBreakerPolicy,
    String? retryPolicy,
    Map<String, String>? metricsTags,
    InterruptionConfig? interruption,
    PreToolSpeechConfig? preToolSpeech,
    ExecutionConfig? execution,
    DynamicVariableConfig? dynamicVariables,
    String? driver,
    String? databasePath,
    double? timeout,
    bool? checkSameThread,
  }}) {
    return SqliteToolSpec(
      id: id ?? this.id,
      version: version ?? this.version,
      toolName: toolName ?? this.toolName,
      description: description ?? this.description,
      toolType: toolType ?? this.toolType,
      parameters: parameters ?? this.parameters,
      returns: returns ?? this.returns,
      returnTarget: returnTarget ?? this.returnTarget,
      required: required ?? this.required,
      owner: owner ?? this.owner,
      permissions: permissions ?? this.permissions,
      timeoutS: timeoutS ?? this.timeoutS,
      examples: examples ?? this.examples,
      retry: retry ?? this.retry,
      circuitBreaker: circuitBreaker ?? this.circuitBreaker,
      idempotency: idempotency ?? this.idempotency,
      idempotencyKeyGenerator: idempotencyKeyGenerator ?? this.idempotencyKeyGenerator,
      circuitBreakerPolicy: circuitBreakerPolicy ?? this.circuitBreakerPolicy,
      retryPolicy: retryPolicy ?? this.retryPolicy,
      metricsTags: metricsTags ?? this.metricsTags,
      interruption: interruption ?? this.interruption,
      preToolSpeech: preToolSpeech ?? this.preToolSpeech,
      execution: execution ?? this.execution,
      dynamicVariables: dynamicVariables ?? this.dynamicVariables,
      driver: driver ?? this.driver,
      databasePath: databasePath ?? this.databasePath,
      timeout: timeout ?? this.timeout,
      checkSameThread: checkSameThread ?? this.checkSameThread,
    );
  }

  factory SqliteToolSpec.empty() {
    return const SqliteToolSpec();
  }
}
