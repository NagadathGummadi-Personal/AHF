// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by scripts/generate_flutter.py

class ToolSpecUISchema {
  static const String modelName = 'ToolSpec';

  static const Map<String, Map<String, dynamic>> fields = {
    'id': {
      'display_name': 'Tool ID',
      'group': 'identity',
      'help_text': 'Unique identifier for the tool (auto-generated from name)',
      'placeholder': 'my-tool-v1',
      'widget_type': 'text',
    },
    'version': {
      'display_name': 'Version',
      'group': 'identity',
      'help_text': 'Tool version string (semver recommended)',
      'order': 1,
      'placeholder': '1.0.0',
      'widget_type': 'text',
    },
    'tool_name': {
      'display_name': 'Display Name',
      'group': 'identity',
      'help_text': 'Human-readable tool name',
      'order': 2,
      'placeholder': 'My Tool',
      'widget_type': 'text',
    },
    'description': {
      'display_name': 'Description',
      'group': 'identity',
      'help_text': 'Tool description (helps LLM understand when to use it)',
      'order': 3,
      'placeholder': 'Describe what this tool does and when to use it...',
      'widget_type': 'textarea',
    },
    'tool_type': {
      'display_name': 'Tool Type',
      'group': 'identity',
      'help_text': 'Type of tool implementation',
      'options': [{"label": "Function (Python)", "value": "function"}, {"label": "HTTP (REST API)", "value": "http"}, {"label": "Database (SQL/NoSQL)", "value": "db"}],
      'order': 4,
      'widget_type': 'dropdown',
    },
    'parameters': {
      'display_name': 'Parameters',
      'group': 'parameters',
      'help_text': 'Input parameters for this tool',
      'item_label': 'Parameter {index}',
      'widget_type': 'array_editor',
    },
    'returns': {
      'display_name': 'Return Type',
      'group': 'return',
      'help_text': 'Format of tool output',
      'options': [{"label": "JSON", "value": "json"}, {"label": "Text", "value": "text"}, {"label": "TOON", "value": "toon"}],
      'widget_type': 'dropdown',
    },
    'return_target': {
      'display_name': 'Return Target',
      'group': 'return',
      'help_text': 'Where to route tool output',
      'options': [{"label": "LLM (continue conversation)", "value": "llm"}, {"label": "Human (direct to user)", "value": "human"}, {"label": "Agent (for agent processing)", "value": "agent"}, {"label": "Step (workflow step output)", "value": "step"}],
      'order': 1,
      'widget_type': 'dropdown',
    },
    'required': {
      'display_name': 'Required Tool',
      'group': 'ownership',
      'help_text': 'Whether this tool must be available for the agent',
      'widget_type': 'switch',
    },
    'owner': {
      'display_name': 'Owner',
      'group': 'ownership',
      'help_text': 'Tool owner identifier',
      'order': 1,
      'placeholder': 'team-name',
      'widget_type': 'text',
    },
    'permissions': {
      'display_name': 'Required Permissions',
      'group': 'ownership',
      'help_text': 'Permissions required to use this tool',
      'item_label': 'Permission {index}',
      'order': 2,
      'widget_type': 'array_editor',
    },
    'timeout_s': {
      'display_name': 'Timeout (seconds)',
      'group': 'execution',
      'help_text': 'Maximum execution time before timeout',
      'max_value': 300,
      'min_value': 1,
      'step': 1,
      'widget_type': 'slider',
    },
    'examples': {
      'display_name': 'Usage Examples',
      'group': 'examples',
      'help_text': 'Example inputs/outputs for documentation',
      'item_label': 'Example {index}',
      'widget_type': 'array_editor',
    },
    'retry': {
      'display_name': 'Retry Configuration',
      'group': 'advanced_retry',
      'help_text': 'Configure automatic retry behavior',
      'widget_type': 'object_editor',
    },
    'circuit_breaker': {
      'display_name': 'Circuit Breaker',
      'group': 'advanced_circuit_breaker',
      'help_text': 'Configure circuit breaker pattern',
      'order': 1,
      'widget_type': 'object_editor',
    },
    'idempotency': {
      'display_name': 'Idempotency',
      'group': 'advanced_idempotency',
      'help_text': 'Configure idempotency behavior',
      'order': 2,
      'widget_type': 'object_editor',
    },
    'idempotency_key_generator': {
      'widget_type': 'hidden',
    },
    'circuit_breaker_policy': {
      'widget_type': 'hidden',
    },
    'retry_policy': {
      'widget_type': 'hidden',
    },
    'metrics_tags': {
      'display_name': 'Metrics Tags',
      'group': 'advanced_metrics',
      'help_text': 'Static tags for metrics/observability',
      'widget_type': 'key_value_editor',
    },
    'interruption': {
      'display_name': 'Interruption Control',
      'group': 'advanced_interruption',
      'help_text': 'Controls whether user input can interrupt tool execution',
      'widget_type': 'object_editor',
    },
    'pre_tool_speech': {
      'display_name': 'Pre-Tool Speech',
      'group': 'advanced_speech',
      'help_text': 'Configuration for what agent says before executing tool',
      'widget_type': 'object_editor',
    },
    'execution': {
      'display_name': 'Execution Mode',
      'group': 'advanced_execution',
      'help_text': 'Controls speech/execution timing',
      'widget_type': 'object_editor',
    },
    'dynamic_variables': {
      'display_name': 'Dynamic Variables',
      'group': 'advanced_dynamic_vars',
      'help_text': 'Configuration for updating variables based on tool results',
      'widget_type': 'object_editor',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class FunctionToolSpecUISchema {
  static const String modelName = 'FunctionToolSpec';

  static const Map<String, Map<String, dynamic>> fields = {
    'id': {
      'display_name': 'Tool ID',
      'group': 'identity',
      'help_text': 'Unique identifier for the tool (auto-generated from name)',
      'placeholder': 'my-tool-v1',
      'widget_type': 'text',
    },
    'version': {
      'display_name': 'Version',
      'group': 'identity',
      'help_text': 'Tool version string (semver recommended)',
      'order': 1,
      'placeholder': '1.0.0',
      'widget_type': 'text',
    },
    'tool_name': {
      'display_name': 'Display Name',
      'group': 'identity',
      'help_text': 'Human-readable tool name',
      'order': 2,
      'placeholder': 'My Tool',
      'widget_type': 'text',
    },
    'description': {
      'display_name': 'Description',
      'group': 'identity',
      'help_text': 'Tool description (helps LLM understand when to use it)',
      'order': 3,
      'placeholder': 'Describe what this tool does and when to use it...',
      'widget_type': 'textarea',
    },
    'tool_type': {
      'widget_type': 'hidden',
    },
    'parameters': {
      'display_name': 'Parameters',
      'group': 'parameters',
      'help_text': 'Input parameters for this tool',
      'item_label': 'Parameter {index}',
      'widget_type': 'array_editor',
    },
    'returns': {
      'display_name': 'Return Type',
      'group': 'return',
      'help_text': 'Format of tool output',
      'options': [{"label": "JSON", "value": "json"}, {"label": "Text", "value": "text"}, {"label": "TOON", "value": "toon"}],
      'widget_type': 'dropdown',
    },
    'return_target': {
      'display_name': 'Return Target',
      'group': 'return',
      'help_text': 'Where to route tool output',
      'options': [{"label": "LLM (continue conversation)", "value": "llm"}, {"label": "Human (direct to user)", "value": "human"}, {"label": "Agent (for agent processing)", "value": "agent"}, {"label": "Step (workflow step output)", "value": "step"}],
      'order': 1,
      'widget_type': 'dropdown',
    },
    'required': {
      'display_name': 'Required Tool',
      'group': 'ownership',
      'help_text': 'Whether this tool must be available for the agent',
      'widget_type': 'switch',
    },
    'owner': {
      'display_name': 'Owner',
      'group': 'ownership',
      'help_text': 'Tool owner identifier',
      'order': 1,
      'placeholder': 'team-name',
      'widget_type': 'text',
    },
    'permissions': {
      'display_name': 'Required Permissions',
      'group': 'ownership',
      'help_text': 'Permissions required to use this tool',
      'item_label': 'Permission {index}',
      'order': 2,
      'widget_type': 'array_editor',
    },
    'timeout_s': {
      'display_name': 'Timeout (seconds)',
      'group': 'execution',
      'help_text': 'Maximum execution time before timeout',
      'max_value': 300,
      'min_value': 1,
      'step': 1,
      'widget_type': 'slider',
    },
    'examples': {
      'display_name': 'Usage Examples',
      'group': 'examples',
      'help_text': 'Example inputs/outputs for documentation',
      'item_label': 'Example {index}',
      'widget_type': 'array_editor',
    },
    'retry': {
      'display_name': 'Retry Configuration',
      'group': 'advanced_retry',
      'help_text': 'Configure automatic retry behavior',
      'widget_type': 'object_editor',
    },
    'circuit_breaker': {
      'display_name': 'Circuit Breaker',
      'group': 'advanced_circuit_breaker',
      'help_text': 'Configure circuit breaker pattern',
      'order': 1,
      'widget_type': 'object_editor',
    },
    'idempotency': {
      'display_name': 'Idempotency',
      'group': 'advanced_idempotency',
      'help_text': 'Configure idempotency behavior',
      'order': 2,
      'widget_type': 'object_editor',
    },
    'idempotency_key_generator': {
      'widget_type': 'hidden',
    },
    'circuit_breaker_policy': {
      'widget_type': 'hidden',
    },
    'retry_policy': {
      'widget_type': 'hidden',
    },
    'metrics_tags': {
      'display_name': 'Metrics Tags',
      'group': 'advanced_metrics',
      'help_text': 'Static tags for metrics/observability',
      'widget_type': 'key_value_editor',
    },
    'interruption': {
      'display_name': 'Interruption Control',
      'group': 'advanced_interruption',
      'help_text': 'Controls whether user input can interrupt tool execution',
      'widget_type': 'object_editor',
    },
    'pre_tool_speech': {
      'display_name': 'Pre-Tool Speech',
      'group': 'advanced_speech',
      'help_text': 'Configuration for what agent says before executing tool',
      'widget_type': 'object_editor',
    },
    'execution': {
      'display_name': 'Execution Mode',
      'group': 'advanced_execution',
      'help_text': 'Controls speech/execution timing',
      'widget_type': 'object_editor',
    },
    'dynamic_variables': {
      'display_name': 'Dynamic Variables',
      'group': 'advanced_dynamic_vars',
      'help_text': 'Configuration for updating variables based on tool results',
      'widget_type': 'object_editor',
    },
    'function_code': {
      'display_name': 'Function Code',
      'group': 'function',
      'help_text': 'Python async function implementation',
      'language': 'python',
      'widget_type': 'code_editor',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class HttpToolSpecUISchema {
  static const String modelName = 'HttpToolSpec';

  static const Map<String, Map<String, dynamic>> fields = {
    'id': {
      'display_name': 'Tool ID',
      'group': 'identity',
      'help_text': 'Unique identifier for the tool (auto-generated from name)',
      'placeholder': 'my-tool-v1',
      'widget_type': 'text',
    },
    'version': {
      'display_name': 'Version',
      'group': 'identity',
      'help_text': 'Tool version string (semver recommended)',
      'order': 1,
      'placeholder': '1.0.0',
      'widget_type': 'text',
    },
    'tool_name': {
      'display_name': 'Display Name',
      'group': 'identity',
      'help_text': 'Human-readable tool name',
      'order': 2,
      'placeholder': 'My Tool',
      'widget_type': 'text',
    },
    'description': {
      'display_name': 'Description',
      'group': 'identity',
      'help_text': 'Tool description (helps LLM understand when to use it)',
      'order': 3,
      'placeholder': 'Describe what this tool does and when to use it...',
      'widget_type': 'textarea',
    },
    'tool_type': {
      'widget_type': 'hidden',
    },
    'parameters': {
      'display_name': 'Parameters',
      'group': 'parameters',
      'help_text': 'Input parameters for this tool',
      'item_label': 'Parameter {index}',
      'widget_type': 'array_editor',
    },
    'returns': {
      'display_name': 'Return Type',
      'group': 'return',
      'help_text': 'Format of tool output',
      'options': [{"label": "JSON", "value": "json"}, {"label": "Text", "value": "text"}, {"label": "TOON", "value": "toon"}],
      'widget_type': 'dropdown',
    },
    'return_target': {
      'display_name': 'Return Target',
      'group': 'return',
      'help_text': 'Where to route tool output',
      'options': [{"label": "LLM (continue conversation)", "value": "llm"}, {"label": "Human (direct to user)", "value": "human"}, {"label": "Agent (for agent processing)", "value": "agent"}, {"label": "Step (workflow step output)", "value": "step"}],
      'order': 1,
      'widget_type': 'dropdown',
    },
    'required': {
      'display_name': 'Required Tool',
      'group': 'ownership',
      'help_text': 'Whether this tool must be available for the agent',
      'widget_type': 'switch',
    },
    'owner': {
      'display_name': 'Owner',
      'group': 'ownership',
      'help_text': 'Tool owner identifier',
      'order': 1,
      'placeholder': 'team-name',
      'widget_type': 'text',
    },
    'permissions': {
      'display_name': 'Required Permissions',
      'group': 'ownership',
      'help_text': 'Permissions required to use this tool',
      'item_label': 'Permission {index}',
      'order': 2,
      'widget_type': 'array_editor',
    },
    'timeout_s': {
      'display_name': 'Timeout (seconds)',
      'group': 'execution',
      'help_text': 'Maximum execution time before timeout',
      'max_value': 300,
      'min_value': 1,
      'step': 1,
      'widget_type': 'slider',
    },
    'examples': {
      'display_name': 'Usage Examples',
      'group': 'examples',
      'help_text': 'Example inputs/outputs for documentation',
      'item_label': 'Example {index}',
      'widget_type': 'array_editor',
    },
    'retry': {
      'display_name': 'Retry Configuration',
      'group': 'advanced_retry',
      'help_text': 'Configure automatic retry behavior',
      'widget_type': 'object_editor',
    },
    'circuit_breaker': {
      'display_name': 'Circuit Breaker',
      'group': 'advanced_circuit_breaker',
      'help_text': 'Configure circuit breaker pattern',
      'order': 1,
      'widget_type': 'object_editor',
    },
    'idempotency': {
      'display_name': 'Idempotency',
      'group': 'advanced_idempotency',
      'help_text': 'Configure idempotency behavior',
      'order': 2,
      'widget_type': 'object_editor',
    },
    'idempotency_key_generator': {
      'widget_type': 'hidden',
    },
    'circuit_breaker_policy': {
      'widget_type': 'hidden',
    },
    'retry_policy': {
      'widget_type': 'hidden',
    },
    'metrics_tags': {
      'display_name': 'Metrics Tags',
      'group': 'advanced_metrics',
      'help_text': 'Static tags for metrics/observability',
      'widget_type': 'key_value_editor',
    },
    'interruption': {
      'display_name': 'Interruption Control',
      'group': 'advanced_interruption',
      'help_text': 'Controls whether user input can interrupt tool execution',
      'widget_type': 'object_editor',
    },
    'pre_tool_speech': {
      'display_name': 'Pre-Tool Speech',
      'group': 'advanced_speech',
      'help_text': 'Configuration for what agent says before executing tool',
      'widget_type': 'object_editor',
    },
    'execution': {
      'display_name': 'Execution Mode',
      'group': 'advanced_execution',
      'help_text': 'Controls speech/execution timing',
      'widget_type': 'object_editor',
    },
    'dynamic_variables': {
      'display_name': 'Dynamic Variables',
      'group': 'advanced_dynamic_vars',
      'help_text': 'Configuration for updating variables based on tool results',
      'widget_type': 'object_editor',
    },
    'url': {
      'display_name': 'URL',
      'group': 'http',
      'help_text': 'API endpoint URL (supports {variable} substitution)',
      'placeholder': 'https://api.example.com/endpoint',
      'widget_type': 'text',
    },
    'method': {
      'display_name': 'HTTP Method',
      'group': 'http',
      'help_text': 'HTTP request method',
      'options': [{"label": "GET", "value": "GET"}, {"label": "POST", "value": "POST"}, {"label": "PUT", "value": "PUT"}, {"label": "PATCH", "value": "PATCH"}, {"label": "DELETE", "value": "DELETE"}],
      'order': 1,
      'widget_type': 'dropdown',
    },
    'headers': {
      'display_name': 'Headers',
      'group': 'http',
      'help_text': 'HTTP headers (use ${VAR} for variable substitution)',
      'order': 2,
      'widget_type': 'key_value_editor',
    },
    'query_params': {
      'display_name': 'Query Parameters',
      'group': 'http',
      'help_text': 'URL query parameters',
      'order': 3,
      'widget_type': 'key_value_editor',
    },
    'body': {
      'display_name': 'Request Body',
      'group': 'http',
      'help_text': 'JSON request body template',
      'language': 'json',
      'order': 4,
      'visible_when': 'method != 'GET'',
      'widget_type': 'code_editor',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class DbToolSpecUISchema {
  static const String modelName = 'DbToolSpec';

  static const Map<String, Map<String, dynamic>> fields = {
    'id': {
      'display_name': 'Tool ID',
      'group': 'identity',
      'help_text': 'Unique identifier for the tool (auto-generated from name)',
      'placeholder': 'my-tool-v1',
      'widget_type': 'text',
    },
    'version': {
      'display_name': 'Version',
      'group': 'identity',
      'help_text': 'Tool version string (semver recommended)',
      'order': 1,
      'placeholder': '1.0.0',
      'widget_type': 'text',
    },
    'tool_name': {
      'display_name': 'Display Name',
      'group': 'identity',
      'help_text': 'Human-readable tool name',
      'order': 2,
      'placeholder': 'My Tool',
      'widget_type': 'text',
    },
    'description': {
      'display_name': 'Description',
      'group': 'identity',
      'help_text': 'Tool description (helps LLM understand when to use it)',
      'order': 3,
      'placeholder': 'Describe what this tool does and when to use it...',
      'widget_type': 'textarea',
    },
    'tool_type': {
      'widget_type': 'hidden',
    },
    'parameters': {
      'display_name': 'Parameters',
      'group': 'parameters',
      'help_text': 'Input parameters for this tool',
      'item_label': 'Parameter {index}',
      'widget_type': 'array_editor',
    },
    'returns': {
      'display_name': 'Return Type',
      'group': 'return',
      'help_text': 'Format of tool output',
      'options': [{"label": "JSON", "value": "json"}, {"label": "Text", "value": "text"}, {"label": "TOON", "value": "toon"}],
      'widget_type': 'dropdown',
    },
    'return_target': {
      'display_name': 'Return Target',
      'group': 'return',
      'help_text': 'Where to route tool output',
      'options': [{"label": "LLM (continue conversation)", "value": "llm"}, {"label": "Human (direct to user)", "value": "human"}, {"label": "Agent (for agent processing)", "value": "agent"}, {"label": "Step (workflow step output)", "value": "step"}],
      'order': 1,
      'widget_type': 'dropdown',
    },
    'required': {
      'display_name': 'Required Tool',
      'group': 'ownership',
      'help_text': 'Whether this tool must be available for the agent',
      'widget_type': 'switch',
    },
    'owner': {
      'display_name': 'Owner',
      'group': 'ownership',
      'help_text': 'Tool owner identifier',
      'order': 1,
      'placeholder': 'team-name',
      'widget_type': 'text',
    },
    'permissions': {
      'display_name': 'Required Permissions',
      'group': 'ownership',
      'help_text': 'Permissions required to use this tool',
      'item_label': 'Permission {index}',
      'order': 2,
      'widget_type': 'array_editor',
    },
    'timeout_s': {
      'display_name': 'Timeout (seconds)',
      'group': 'execution',
      'help_text': 'Maximum execution time before timeout',
      'max_value': 300,
      'min_value': 1,
      'step': 1,
      'widget_type': 'slider',
    },
    'examples': {
      'display_name': 'Usage Examples',
      'group': 'examples',
      'help_text': 'Example inputs/outputs for documentation',
      'item_label': 'Example {index}',
      'widget_type': 'array_editor',
    },
    'retry': {
      'display_name': 'Retry Configuration',
      'group': 'advanced_retry',
      'help_text': 'Configure automatic retry behavior',
      'widget_type': 'object_editor',
    },
    'circuit_breaker': {
      'display_name': 'Circuit Breaker',
      'group': 'advanced_circuit_breaker',
      'help_text': 'Configure circuit breaker pattern',
      'order': 1,
      'widget_type': 'object_editor',
    },
    'idempotency': {
      'display_name': 'Idempotency',
      'group': 'advanced_idempotency',
      'help_text': 'Configure idempotency behavior',
      'order': 2,
      'widget_type': 'object_editor',
    },
    'idempotency_key_generator': {
      'widget_type': 'hidden',
    },
    'circuit_breaker_policy': {
      'widget_type': 'hidden',
    },
    'retry_policy': {
      'widget_type': 'hidden',
    },
    'metrics_tags': {
      'display_name': 'Metrics Tags',
      'group': 'advanced_metrics',
      'help_text': 'Static tags for metrics/observability',
      'widget_type': 'key_value_editor',
    },
    'interruption': {
      'display_name': 'Interruption Control',
      'group': 'advanced_interruption',
      'help_text': 'Controls whether user input can interrupt tool execution',
      'widget_type': 'object_editor',
    },
    'pre_tool_speech': {
      'display_name': 'Pre-Tool Speech',
      'group': 'advanced_speech',
      'help_text': 'Configuration for what agent says before executing tool',
      'widget_type': 'object_editor',
    },
    'execution': {
      'display_name': 'Execution Mode',
      'group': 'advanced_execution',
      'help_text': 'Controls speech/execution timing',
      'widget_type': 'object_editor',
    },
    'dynamic_variables': {
      'display_name': 'Dynamic Variables',
      'group': 'advanced_dynamic_vars',
      'help_text': 'Configuration for updating variables based on tool results',
      'widget_type': 'object_editor',
    },
    'driver': {
      'display_name': 'Database Driver',
      'group': 'db',
      'help_text': 'Database driver/provider',
      'options': [{"label": "PostgreSQL", "value": "postgresql"}, {"label": "MySQL", "value": "mysql"}, {"label": "SQLite", "value": "sqlite"}, {"label": "DynamoDB", "value": "dynamodb"}, {"label": "MongoDB", "value": "mongodb"}, {"label": "SQL Server", "value": "mssql"}],
      'widget_type': 'dropdown',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class DynamoDbToolSpecUISchema {
  static const String modelName = 'DynamoDbToolSpec';

  static const Map<String, Map<String, dynamic>> fields = {
    'id': {
      'display_name': 'Tool ID',
      'group': 'identity',
      'help_text': 'Unique identifier for the tool (auto-generated from name)',
      'placeholder': 'my-tool-v1',
      'widget_type': 'text',
    },
    'version': {
      'display_name': 'Version',
      'group': 'identity',
      'help_text': 'Tool version string (semver recommended)',
      'order': 1,
      'placeholder': '1.0.0',
      'widget_type': 'text',
    },
    'tool_name': {
      'display_name': 'Display Name',
      'group': 'identity',
      'help_text': 'Human-readable tool name',
      'order': 2,
      'placeholder': 'My Tool',
      'widget_type': 'text',
    },
    'description': {
      'display_name': 'Description',
      'group': 'identity',
      'help_text': 'Tool description (helps LLM understand when to use it)',
      'order': 3,
      'placeholder': 'Describe what this tool does and when to use it...',
      'widget_type': 'textarea',
    },
    'tool_type': {
      'widget_type': 'hidden',
    },
    'parameters': {
      'display_name': 'Parameters',
      'group': 'parameters',
      'help_text': 'Input parameters for this tool',
      'item_label': 'Parameter {index}',
      'widget_type': 'array_editor',
    },
    'returns': {
      'display_name': 'Return Type',
      'group': 'return',
      'help_text': 'Format of tool output',
      'options': [{"label": "JSON", "value": "json"}, {"label": "Text", "value": "text"}, {"label": "TOON", "value": "toon"}],
      'widget_type': 'dropdown',
    },
    'return_target': {
      'display_name': 'Return Target',
      'group': 'return',
      'help_text': 'Where to route tool output',
      'options': [{"label": "LLM (continue conversation)", "value": "llm"}, {"label": "Human (direct to user)", "value": "human"}, {"label": "Agent (for agent processing)", "value": "agent"}, {"label": "Step (workflow step output)", "value": "step"}],
      'order': 1,
      'widget_type': 'dropdown',
    },
    'required': {
      'display_name': 'Required Tool',
      'group': 'ownership',
      'help_text': 'Whether this tool must be available for the agent',
      'widget_type': 'switch',
    },
    'owner': {
      'display_name': 'Owner',
      'group': 'ownership',
      'help_text': 'Tool owner identifier',
      'order': 1,
      'placeholder': 'team-name',
      'widget_type': 'text',
    },
    'permissions': {
      'display_name': 'Required Permissions',
      'group': 'ownership',
      'help_text': 'Permissions required to use this tool',
      'item_label': 'Permission {index}',
      'order': 2,
      'widget_type': 'array_editor',
    },
    'timeout_s': {
      'display_name': 'Timeout (seconds)',
      'group': 'execution',
      'help_text': 'Maximum execution time before timeout',
      'max_value': 300,
      'min_value': 1,
      'step': 1,
      'widget_type': 'slider',
    },
    'examples': {
      'display_name': 'Usage Examples',
      'group': 'examples',
      'help_text': 'Example inputs/outputs for documentation',
      'item_label': 'Example {index}',
      'widget_type': 'array_editor',
    },
    'retry': {
      'display_name': 'Retry Configuration',
      'group': 'advanced_retry',
      'help_text': 'Configure automatic retry behavior',
      'widget_type': 'object_editor',
    },
    'circuit_breaker': {
      'display_name': 'Circuit Breaker',
      'group': 'advanced_circuit_breaker',
      'help_text': 'Configure circuit breaker pattern',
      'order': 1,
      'widget_type': 'object_editor',
    },
    'idempotency': {
      'display_name': 'Idempotency',
      'group': 'advanced_idempotency',
      'help_text': 'Configure idempotency behavior',
      'order': 2,
      'widget_type': 'object_editor',
    },
    'idempotency_key_generator': {
      'widget_type': 'hidden',
    },
    'circuit_breaker_policy': {
      'widget_type': 'hidden',
    },
    'retry_policy': {
      'widget_type': 'hidden',
    },
    'metrics_tags': {
      'display_name': 'Metrics Tags',
      'group': 'advanced_metrics',
      'help_text': 'Static tags for metrics/observability',
      'widget_type': 'key_value_editor',
    },
    'interruption': {
      'display_name': 'Interruption Control',
      'group': 'advanced_interruption',
      'help_text': 'Controls whether user input can interrupt tool execution',
      'widget_type': 'object_editor',
    },
    'pre_tool_speech': {
      'display_name': 'Pre-Tool Speech',
      'group': 'advanced_speech',
      'help_text': 'Configuration for what agent says before executing tool',
      'widget_type': 'object_editor',
    },
    'execution': {
      'display_name': 'Execution Mode',
      'group': 'advanced_execution',
      'help_text': 'Controls speech/execution timing',
      'widget_type': 'object_editor',
    },
    'dynamic_variables': {
      'display_name': 'Dynamic Variables',
      'group': 'advanced_dynamic_vars',
      'help_text': 'Configuration for updating variables based on tool results',
      'widget_type': 'object_editor',
    },
    'driver': {
      'widget_type': 'hidden',
    },
    'region': {
      'display_name': 'AWS Region',
      'group': 'dynamodb',
      'help_text': 'AWS region for DynamoDB',
      'options': [{"label": "US East (N. Virginia)", "value": "us-east-1"}, {"label": "US East (Ohio)", "value": "us-east-2"}, {"label": "US West (N. California)", "value": "us-west-1"}, {"label": "US West (Oregon)", "value": "us-west-2"}, {"label": "EU (Ireland)", "value": "eu-west-1"}, {"label": "EU (Frankfurt)", "value": "eu-central-1"}, {"label": "Asia Pacific (Singapore)", "value": "ap-southeast-1"}, {"label": "Asia Pacific (Tokyo)", "value": "ap-northeast-1"}],
      'order': 1,
      'widget_type': 'dropdown',
    },
    'table_name': {
      'display_name': 'Table Name',
      'group': 'dynamodb',
      'help_text': 'DynamoDB table name',
      'order': 2,
      'placeholder': 'my-table',
      'widget_type': 'text',
    },
    'endpoint_url': {
      'display_name': 'Endpoint URL (Optional)',
      'group': 'dynamodb',
      'help_text': 'Custom endpoint for LocalStack/testing',
      'order': 3,
      'placeholder': 'http://localhost:8000',
      'widget_type': 'text',
    },
    'aws_access_key_id': {
      'display_name': 'AWS Access Key ID (Optional)',
      'group': 'dynamodb',
      'help_text': 'Prefer IAM roles over hardcoded credentials',
      'order': 4,
      'placeholder': 'Leave empty for IAM role',
      'widget_type': 'text',
    },
    'aws_secret_access_key': {
      'display_name': 'AWS Secret Access Key',
      'group': 'dynamodb',
      'help_text': 'Prefer IAM roles over hardcoded credentials',
      'order': 5,
      'placeholder': 'Leave empty for IAM role',
      'widget_type': 'text',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class PostgreSqlToolSpecUISchema {
  static const String modelName = 'PostgreSqlToolSpec';

  static const Map<String, Map<String, dynamic>> fields = {
    'id': {
      'display_name': 'Tool ID',
      'group': 'identity',
      'help_text': 'Unique identifier for the tool (auto-generated from name)',
      'placeholder': 'my-tool-v1',
      'widget_type': 'text',
    },
    'version': {
      'display_name': 'Version',
      'group': 'identity',
      'help_text': 'Tool version string (semver recommended)',
      'order': 1,
      'placeholder': '1.0.0',
      'widget_type': 'text',
    },
    'tool_name': {
      'display_name': 'Display Name',
      'group': 'identity',
      'help_text': 'Human-readable tool name',
      'order': 2,
      'placeholder': 'My Tool',
      'widget_type': 'text',
    },
    'description': {
      'display_name': 'Description',
      'group': 'identity',
      'help_text': 'Tool description (helps LLM understand when to use it)',
      'order': 3,
      'placeholder': 'Describe what this tool does and when to use it...',
      'widget_type': 'textarea',
    },
    'tool_type': {
      'widget_type': 'hidden',
    },
    'parameters': {
      'display_name': 'Parameters',
      'group': 'parameters',
      'help_text': 'Input parameters for this tool',
      'item_label': 'Parameter {index}',
      'widget_type': 'array_editor',
    },
    'returns': {
      'display_name': 'Return Type',
      'group': 'return',
      'help_text': 'Format of tool output',
      'options': [{"label": "JSON", "value": "json"}, {"label": "Text", "value": "text"}, {"label": "TOON", "value": "toon"}],
      'widget_type': 'dropdown',
    },
    'return_target': {
      'display_name': 'Return Target',
      'group': 'return',
      'help_text': 'Where to route tool output',
      'options': [{"label": "LLM (continue conversation)", "value": "llm"}, {"label": "Human (direct to user)", "value": "human"}, {"label": "Agent (for agent processing)", "value": "agent"}, {"label": "Step (workflow step output)", "value": "step"}],
      'order': 1,
      'widget_type': 'dropdown',
    },
    'required': {
      'display_name': 'Required Tool',
      'group': 'ownership',
      'help_text': 'Whether this tool must be available for the agent',
      'widget_type': 'switch',
    },
    'owner': {
      'display_name': 'Owner',
      'group': 'ownership',
      'help_text': 'Tool owner identifier',
      'order': 1,
      'placeholder': 'team-name',
      'widget_type': 'text',
    },
    'permissions': {
      'display_name': 'Required Permissions',
      'group': 'ownership',
      'help_text': 'Permissions required to use this tool',
      'item_label': 'Permission {index}',
      'order': 2,
      'widget_type': 'array_editor',
    },
    'timeout_s': {
      'display_name': 'Timeout (seconds)',
      'group': 'execution',
      'help_text': 'Maximum execution time before timeout',
      'max_value': 300,
      'min_value': 1,
      'step': 1,
      'widget_type': 'slider',
    },
    'examples': {
      'display_name': 'Usage Examples',
      'group': 'examples',
      'help_text': 'Example inputs/outputs for documentation',
      'item_label': 'Example {index}',
      'widget_type': 'array_editor',
    },
    'retry': {
      'display_name': 'Retry Configuration',
      'group': 'advanced_retry',
      'help_text': 'Configure automatic retry behavior',
      'widget_type': 'object_editor',
    },
    'circuit_breaker': {
      'display_name': 'Circuit Breaker',
      'group': 'advanced_circuit_breaker',
      'help_text': 'Configure circuit breaker pattern',
      'order': 1,
      'widget_type': 'object_editor',
    },
    'idempotency': {
      'display_name': 'Idempotency',
      'group': 'advanced_idempotency',
      'help_text': 'Configure idempotency behavior',
      'order': 2,
      'widget_type': 'object_editor',
    },
    'idempotency_key_generator': {
      'widget_type': 'hidden',
    },
    'circuit_breaker_policy': {
      'widget_type': 'hidden',
    },
    'retry_policy': {
      'widget_type': 'hidden',
    },
    'metrics_tags': {
      'display_name': 'Metrics Tags',
      'group': 'advanced_metrics',
      'help_text': 'Static tags for metrics/observability',
      'widget_type': 'key_value_editor',
    },
    'interruption': {
      'display_name': 'Interruption Control',
      'group': 'advanced_interruption',
      'help_text': 'Controls whether user input can interrupt tool execution',
      'widget_type': 'object_editor',
    },
    'pre_tool_speech': {
      'display_name': 'Pre-Tool Speech',
      'group': 'advanced_speech',
      'help_text': 'Configuration for what agent says before executing tool',
      'widget_type': 'object_editor',
    },
    'execution': {
      'display_name': 'Execution Mode',
      'group': 'advanced_execution',
      'help_text': 'Controls speech/execution timing',
      'widget_type': 'object_editor',
    },
    'dynamic_variables': {
      'display_name': 'Dynamic Variables',
      'group': 'advanced_dynamic_vars',
      'help_text': 'Configuration for updating variables based on tool results',
      'widget_type': 'object_editor',
    },
    'driver': {
      'widget_type': 'hidden',
    },
    'host': {
      'display_name': 'Host',
      'group': 'postgresql',
      'help_text': 'Database host',
      'order': 1,
      'placeholder': 'localhost',
      'widget_type': 'text',
    },
    'port': {
      'display_name': 'Port',
      'group': 'postgresql',
      'help_text': 'Database port (default: 5432)',
      'max_value': 65535,
      'min_value': 1,
      'order': 2,
      'widget_type': 'number',
    },
    'database': {
      'display_name': 'Database Name',
      'group': 'postgresql',
      'help_text': 'Database name',
      'order': 3,
      'placeholder': 'mydb',
      'widget_type': 'text',
    },
    'username': {
      'display_name': 'Username',
      'group': 'postgresql',
      'help_text': 'Database username',
      'order': 4,
      'placeholder': 'postgres',
      'widget_type': 'text',
    },
    'password': {
      'display_name': 'Password',
      'group': 'postgresql',
      'help_text': 'Database password',
      'order': 5,
      'widget_type': 'text',
    },
    'connection_string': {
      'display_name': 'Connection String (Optional)',
      'group': 'postgresql',
      'help_text': 'Full connection string (overrides individual fields)',
      'order': 6,
      'placeholder': 'postgresql://user:pass@host:5432/db',
      'widget_type': 'text',
    },
    'ssl_mode': {
      'display_name': 'SSL Mode',
      'group': 'postgresql',
      'help_text': 'SSL connection mode',
      'options': [{"label": "Default", "value": ""}, {"label": "Disable", "value": "disable"}, {"label": "Allow", "value": "allow"}, {"label": "Prefer", "value": "prefer"}, {"label": "Require", "value": "require"}],
      'order': 7,
      'widget_type': 'dropdown',
    },
    'pool_size': {
      'display_name': 'Pool Size',
      'group': 'postgresql',
      'help_text': 'Connection pool size',
      'max_value': 100,
      'min_value': 1,
      'order': 8,
      'step': 1,
      'widget_type': 'slider',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class MySqlToolSpecUISchema {
  static const String modelName = 'MySqlToolSpec';

  static const Map<String, Map<String, dynamic>> fields = {
    'id': {
      'display_name': 'Tool ID',
      'group': 'identity',
      'help_text': 'Unique identifier for the tool (auto-generated from name)',
      'placeholder': 'my-tool-v1',
      'widget_type': 'text',
    },
    'version': {
      'display_name': 'Version',
      'group': 'identity',
      'help_text': 'Tool version string (semver recommended)',
      'order': 1,
      'placeholder': '1.0.0',
      'widget_type': 'text',
    },
    'tool_name': {
      'display_name': 'Display Name',
      'group': 'identity',
      'help_text': 'Human-readable tool name',
      'order': 2,
      'placeholder': 'My Tool',
      'widget_type': 'text',
    },
    'description': {
      'display_name': 'Description',
      'group': 'identity',
      'help_text': 'Tool description (helps LLM understand when to use it)',
      'order': 3,
      'placeholder': 'Describe what this tool does and when to use it...',
      'widget_type': 'textarea',
    },
    'tool_type': {
      'widget_type': 'hidden',
    },
    'parameters': {
      'display_name': 'Parameters',
      'group': 'parameters',
      'help_text': 'Input parameters for this tool',
      'item_label': 'Parameter {index}',
      'widget_type': 'array_editor',
    },
    'returns': {
      'display_name': 'Return Type',
      'group': 'return',
      'help_text': 'Format of tool output',
      'options': [{"label": "JSON", "value": "json"}, {"label": "Text", "value": "text"}, {"label": "TOON", "value": "toon"}],
      'widget_type': 'dropdown',
    },
    'return_target': {
      'display_name': 'Return Target',
      'group': 'return',
      'help_text': 'Where to route tool output',
      'options': [{"label": "LLM (continue conversation)", "value": "llm"}, {"label": "Human (direct to user)", "value": "human"}, {"label": "Agent (for agent processing)", "value": "agent"}, {"label": "Step (workflow step output)", "value": "step"}],
      'order': 1,
      'widget_type': 'dropdown',
    },
    'required': {
      'display_name': 'Required Tool',
      'group': 'ownership',
      'help_text': 'Whether this tool must be available for the agent',
      'widget_type': 'switch',
    },
    'owner': {
      'display_name': 'Owner',
      'group': 'ownership',
      'help_text': 'Tool owner identifier',
      'order': 1,
      'placeholder': 'team-name',
      'widget_type': 'text',
    },
    'permissions': {
      'display_name': 'Required Permissions',
      'group': 'ownership',
      'help_text': 'Permissions required to use this tool',
      'item_label': 'Permission {index}',
      'order': 2,
      'widget_type': 'array_editor',
    },
    'timeout_s': {
      'display_name': 'Timeout (seconds)',
      'group': 'execution',
      'help_text': 'Maximum execution time before timeout',
      'max_value': 300,
      'min_value': 1,
      'step': 1,
      'widget_type': 'slider',
    },
    'examples': {
      'display_name': 'Usage Examples',
      'group': 'examples',
      'help_text': 'Example inputs/outputs for documentation',
      'item_label': 'Example {index}',
      'widget_type': 'array_editor',
    },
    'retry': {
      'display_name': 'Retry Configuration',
      'group': 'advanced_retry',
      'help_text': 'Configure automatic retry behavior',
      'widget_type': 'object_editor',
    },
    'circuit_breaker': {
      'display_name': 'Circuit Breaker',
      'group': 'advanced_circuit_breaker',
      'help_text': 'Configure circuit breaker pattern',
      'order': 1,
      'widget_type': 'object_editor',
    },
    'idempotency': {
      'display_name': 'Idempotency',
      'group': 'advanced_idempotency',
      'help_text': 'Configure idempotency behavior',
      'order': 2,
      'widget_type': 'object_editor',
    },
    'idempotency_key_generator': {
      'widget_type': 'hidden',
    },
    'circuit_breaker_policy': {
      'widget_type': 'hidden',
    },
    'retry_policy': {
      'widget_type': 'hidden',
    },
    'metrics_tags': {
      'display_name': 'Metrics Tags',
      'group': 'advanced_metrics',
      'help_text': 'Static tags for metrics/observability',
      'widget_type': 'key_value_editor',
    },
    'interruption': {
      'display_name': 'Interruption Control',
      'group': 'advanced_interruption',
      'help_text': 'Controls whether user input can interrupt tool execution',
      'widget_type': 'object_editor',
    },
    'pre_tool_speech': {
      'display_name': 'Pre-Tool Speech',
      'group': 'advanced_speech',
      'help_text': 'Configuration for what agent says before executing tool',
      'widget_type': 'object_editor',
    },
    'execution': {
      'display_name': 'Execution Mode',
      'group': 'advanced_execution',
      'help_text': 'Controls speech/execution timing',
      'widget_type': 'object_editor',
    },
    'dynamic_variables': {
      'display_name': 'Dynamic Variables',
      'group': 'advanced_dynamic_vars',
      'help_text': 'Configuration for updating variables based on tool results',
      'widget_type': 'object_editor',
    },
    'driver': {
      'widget_type': 'hidden',
    },
    'host': {
      'display_name': 'Host',
      'group': 'mysql',
      'help_text': 'Database host',
      'order': 1,
      'placeholder': 'localhost',
      'widget_type': 'text',
    },
    'port': {
      'display_name': 'Port',
      'group': 'mysql',
      'help_text': 'Database port (default: 3306)',
      'max_value': 65535,
      'min_value': 1,
      'order': 2,
      'widget_type': 'number',
    },
    'database': {
      'display_name': 'Database Name',
      'group': 'mysql',
      'help_text': 'Database name',
      'order': 3,
      'placeholder': 'mydb',
      'widget_type': 'text',
    },
    'username': {
      'display_name': 'Username',
      'group': 'mysql',
      'help_text': 'Database username',
      'order': 4,
      'placeholder': 'root',
      'widget_type': 'text',
    },
    'password': {
      'display_name': 'Password',
      'group': 'mysql',
      'help_text': 'Database password',
      'order': 5,
      'widget_type': 'text',
    },
    'connection_string': {
      'display_name': 'Connection String (Optional)',
      'group': 'mysql',
      'help_text': 'Full connection string (overrides individual fields)',
      'order': 6,
      'placeholder': 'mysql://user:pass@host:3306/db',
      'widget_type': 'text',
    },
    'charset': {
      'display_name': 'Charset',
      'group': 'mysql',
      'help_text': 'Character set',
      'order': 7,
      'placeholder': 'utf8mb4',
      'widget_type': 'text',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class SqliteToolSpecUISchema {
  static const String modelName = 'SqliteToolSpec';

  static const Map<String, Map<String, dynamic>> fields = {
    'id': {
      'display_name': 'Tool ID',
      'group': 'identity',
      'help_text': 'Unique identifier for the tool (auto-generated from name)',
      'placeholder': 'my-tool-v1',
      'widget_type': 'text',
    },
    'version': {
      'display_name': 'Version',
      'group': 'identity',
      'help_text': 'Tool version string (semver recommended)',
      'order': 1,
      'placeholder': '1.0.0',
      'widget_type': 'text',
    },
    'tool_name': {
      'display_name': 'Display Name',
      'group': 'identity',
      'help_text': 'Human-readable tool name',
      'order': 2,
      'placeholder': 'My Tool',
      'widget_type': 'text',
    },
    'description': {
      'display_name': 'Description',
      'group': 'identity',
      'help_text': 'Tool description (helps LLM understand when to use it)',
      'order': 3,
      'placeholder': 'Describe what this tool does and when to use it...',
      'widget_type': 'textarea',
    },
    'tool_type': {
      'widget_type': 'hidden',
    },
    'parameters': {
      'display_name': 'Parameters',
      'group': 'parameters',
      'help_text': 'Input parameters for this tool',
      'item_label': 'Parameter {index}',
      'widget_type': 'array_editor',
    },
    'returns': {
      'display_name': 'Return Type',
      'group': 'return',
      'help_text': 'Format of tool output',
      'options': [{"label": "JSON", "value": "json"}, {"label": "Text", "value": "text"}, {"label": "TOON", "value": "toon"}],
      'widget_type': 'dropdown',
    },
    'return_target': {
      'display_name': 'Return Target',
      'group': 'return',
      'help_text': 'Where to route tool output',
      'options': [{"label": "LLM (continue conversation)", "value": "llm"}, {"label": "Human (direct to user)", "value": "human"}, {"label": "Agent (for agent processing)", "value": "agent"}, {"label": "Step (workflow step output)", "value": "step"}],
      'order': 1,
      'widget_type': 'dropdown',
    },
    'required': {
      'display_name': 'Required Tool',
      'group': 'ownership',
      'help_text': 'Whether this tool must be available for the agent',
      'widget_type': 'switch',
    },
    'owner': {
      'display_name': 'Owner',
      'group': 'ownership',
      'help_text': 'Tool owner identifier',
      'order': 1,
      'placeholder': 'team-name',
      'widget_type': 'text',
    },
    'permissions': {
      'display_name': 'Required Permissions',
      'group': 'ownership',
      'help_text': 'Permissions required to use this tool',
      'item_label': 'Permission {index}',
      'order': 2,
      'widget_type': 'array_editor',
    },
    'timeout_s': {
      'display_name': 'Timeout (seconds)',
      'group': 'execution',
      'help_text': 'Maximum execution time before timeout',
      'max_value': 300,
      'min_value': 1,
      'step': 1,
      'widget_type': 'slider',
    },
    'examples': {
      'display_name': 'Usage Examples',
      'group': 'examples',
      'help_text': 'Example inputs/outputs for documentation',
      'item_label': 'Example {index}',
      'widget_type': 'array_editor',
    },
    'retry': {
      'display_name': 'Retry Configuration',
      'group': 'advanced_retry',
      'help_text': 'Configure automatic retry behavior',
      'widget_type': 'object_editor',
    },
    'circuit_breaker': {
      'display_name': 'Circuit Breaker',
      'group': 'advanced_circuit_breaker',
      'help_text': 'Configure circuit breaker pattern',
      'order': 1,
      'widget_type': 'object_editor',
    },
    'idempotency': {
      'display_name': 'Idempotency',
      'group': 'advanced_idempotency',
      'help_text': 'Configure idempotency behavior',
      'order': 2,
      'widget_type': 'object_editor',
    },
    'idempotency_key_generator': {
      'widget_type': 'hidden',
    },
    'circuit_breaker_policy': {
      'widget_type': 'hidden',
    },
    'retry_policy': {
      'widget_type': 'hidden',
    },
    'metrics_tags': {
      'display_name': 'Metrics Tags',
      'group': 'advanced_metrics',
      'help_text': 'Static tags for metrics/observability',
      'widget_type': 'key_value_editor',
    },
    'interruption': {
      'display_name': 'Interruption Control',
      'group': 'advanced_interruption',
      'help_text': 'Controls whether user input can interrupt tool execution',
      'widget_type': 'object_editor',
    },
    'pre_tool_speech': {
      'display_name': 'Pre-Tool Speech',
      'group': 'advanced_speech',
      'help_text': 'Configuration for what agent says before executing tool',
      'widget_type': 'object_editor',
    },
    'execution': {
      'display_name': 'Execution Mode',
      'group': 'advanced_execution',
      'help_text': 'Controls speech/execution timing',
      'widget_type': 'object_editor',
    },
    'dynamic_variables': {
      'display_name': 'Dynamic Variables',
      'group': 'advanced_dynamic_vars',
      'help_text': 'Configuration for updating variables based on tool results',
      'widget_type': 'object_editor',
    },
    'driver': {
      'widget_type': 'hidden',
    },
    'database_path': {
      'display_name': 'Database Path',
      'group': 'sqlite',
      'help_text': 'Path to SQLite database file (:memory: for in-memory)',
      'order': 1,
      'placeholder': '/path/to/database.db',
      'widget_type': 'text',
    },
    'timeout': {
      'display_name': 'Connection Timeout',
      'group': 'sqlite',
      'help_text': 'Connection timeout in seconds',
      'max_value': 60,
      'min_value': 0.1,
      'order': 2,
      'placeholder': 'seconds',
      'step': 0.1,
      'widget_type': 'number',
    },
    'check_same_thread': {
      'display_name': 'Check Same Thread',
      'group': 'sqlite',
      'help_text': 'Enable thread safety check (disable for async)',
      'order': 3,
      'widget_type': 'switch',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}
