// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by scripts/generate_flutter.py

class RetryConfigUISchema {
  static const String modelName = 'RetryConfig';

  static const Map<String, Map<String, dynamic>> fields = {
    'enabled': {
      'display_name': 'Enable Retries',
      'group': 'retry',
      'help_text': 'Automatically retry on transient failures',
      'widget_type': 'switch',
    },
    'max_attempts': {
      'display_name': 'Max Retry Attempts',
      'group': 'retry',
      'help_text': 'Maximum number of retry attempts before giving up',
      'max_value': 10,
      'min_value': 1,
      'order': 1,
      'step': 1,
      'visible_when': 'enabled == true',
      'widget_type': 'slider',
    },
    'base_delay_s': {
      'display_name': 'Base Delay',
      'group': 'retry',
      'help_text': 'Initial delay between retries (seconds)',
      'max_value': 60,
      'min_value': 0.1,
      'order': 2,
      'placeholder': 'seconds',
      'step': 0.1,
      'visible_when': 'enabled == true',
      'widget_type': 'number',
    },
    'max_delay_s': {
      'display_name': 'Max Delay',
      'group': 'retry',
      'help_text': 'Maximum delay between retries with exponential backoff',
      'max_value': 300,
      'min_value': 1,
      'order': 3,
      'placeholder': 'seconds',
      'step': 0.1,
      'visible_when': 'enabled == true',
      'widget_type': 'number',
    },
    'jitter_s': {
      'display_name': 'Jitter',
      'group': 'retry',
      'help_text': 'Random jitter added to delay to prevent thundering herd',
      'max_value': 10,
      'min_value': 0,
      'order': 4,
      'placeholder': 'seconds',
      'step': 0.1,
      'visible_when': 'enabled == true',
      'widget_type': 'number',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class CircuitBreakerConfigUISchema {
  static const String modelName = 'CircuitBreakerConfig';

  static const Map<String, Map<String, dynamic>> fields = {
    'enabled': {
      'display_name': 'Enable Circuit Breaker',
      'group': 'circuit_breaker',
      'help_text': 'Fail fast when service is unhealthy to prevent cascading failures',
      'widget_type': 'switch',
    },
    'failure_threshold': {
      'display_name': 'Failure Threshold',
      'group': 'circuit_breaker',
      'help_text': 'Consecutive failures before opening the circuit',
      'max_value': 20,
      'min_value': 1,
      'order': 1,
      'step': 1,
      'visible_when': 'enabled == true',
      'widget_type': 'slider',
    },
    'recovery_timeout_s': {
      'display_name': 'Recovery Timeout',
      'group': 'circuit_breaker',
      'help_text': 'Seconds to wait before attempting recovery (OPEN â†’ HALF_OPEN)',
      'max_value': 600,
      'min_value': 5,
      'order': 2,
      'step': 5,
      'visible_when': 'enabled == true',
      'widget_type': 'number',
    },
    'half_open_max_calls': {
      'display_name': 'Half-Open Max Calls',
      'group': 'circuit_breaker',
      'help_text': 'Number of test calls allowed in HALF_OPEN state',
      'max_value': 10,
      'min_value': 1,
      'order': 3,
      'step': 1,
      'visible_when': 'enabled == true',
      'widget_type': 'slider',
    },
    'error_codes_to_trip': {
      'display_name': 'Error Codes to Trip',
      'group': 'circuit_breaker',
      'help_text': 'Error codes that should trip the circuit breaker',
      'item_label': 'Error Code {index}',
      'order': 4,
      'visible_when': 'enabled == true',
      'widget_type': 'array_editor',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class IdempotencyConfigUISchema {
  static const String modelName = 'IdempotencyConfig';

  static const Map<String, Map<String, dynamic>> fields = {
    'enabled': {
      'display_name': 'Enable Idempotency',
      'group': 'idempotency',
      'help_text': 'Cache and guard against repeated executions using key fields',
      'widget_type': 'switch',
    },
    'key_fields': {
      'display_name': 'Key Fields',
      'group': 'idempotency',
      'help_text': 'Fields to use for idempotency key (empty = all args)',
      'item_label': 'Field {index}',
      'order': 1,
      'visible_when': 'enabled == true',
      'widget_type': 'array_editor',
    },
    'ttl_s': {
      'display_name': 'TTL (seconds)',
      'group': 'idempotency',
      'help_text': 'Time-to-live for cached results',
      'max_value': 86400,
      'min_value': 60,
      'order': 2,
      'step': 60,
      'visible_when': 'enabled == true',
      'widget_type': 'number',
    },
    'persist_result': {
      'display_name': 'Persist Result',
      'group': 'idempotency',
      'help_text': 'Store result for reuse on duplicate calls',
      'order': 3,
      'visible_when': 'enabled == true',
      'widget_type': 'switch',
    },
    'bypass_on_missing_key': {
      'display_name': 'Bypass on Missing Key',
      'group': 'idempotency',
      'help_text': 'Skip idempotency check if key fields are missing',
      'order': 4,
      'visible_when': 'enabled == true',
      'widget_type': 'switch',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class InterruptionConfigUISchema {
  static const String modelName = 'InterruptionConfig';

  static const Map<String, Map<String, dynamic>> fields = {
    'disabled': {
      'display_name': 'Disable Interruption',
      'group': 'interruption',
      'help_text': 'If enabled, tool execution cannot be interrupted by user input',
      'widget_type': 'switch',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class PreToolSpeechConfigUISchema {
  static const String modelName = 'PreToolSpeechConfig';

  static const Map<String, Map<String, dynamic>> fields = {
    'enabled': {
      'display_name': 'Enable Pre-Tool Speech',
      'group': 'speech',
      'help_text': 'Whether to speak/announce before tool execution',
      'widget_type': 'switch',
    },
    'mode': {
      'display_name': 'Speech Mode',
      'group': 'speech',
      'help_text': 'How to generate the pre-tool speech',
      'options': [{"label": "Auto (LLM generates)", "value": "auto"}, {"label": "Random (from list)", "value": "random"}, {"label": "Constant (fixed message)", "value": "constant"}],
      'order': 1,
      'visible_when': 'enabled == true',
      'widget_type': 'dropdown',
    },
    'constant_message': {
      'display_name': 'Constant Message',
      'group': 'speech',
      'help_text': 'Fixed message to use when mode is CONSTANT',
      'order': 2,
      'placeholder': 'Processing your request...',
      'visible_when': 'enabled == true && mode == 'constant'',
      'widget_type': 'text',
    },
    'random_messages': {
      'display_name': 'Random Messages',
      'group': 'speech',
      'help_text': 'List of messages to randomly select from',
      'item_label': 'Message {index}',
      'order': 3,
      'visible_when': 'enabled == true && mode == 'random'',
      'widget_type': 'array_editor',
    },
    'context_scope': {
      'display_name': 'Context Scope',
      'group': 'speech_auto',
      'help_text': 'What context the LLM uses when generating speech',
      'options': [{"label": "Full Context", "value": "full_context"}, {"label": "Tool Only", "value": "tool_only"}, {"label": "Last Message", "value": "last_message"}, {"label": "Custom Instruction", "value": "custom"}],
      'order': 4,
      'visible_when': 'enabled == true && mode == 'auto'',
      'widget_type': 'dropdown',
    },
    'llm_instruction': {
      'display_name': 'Custom LLM Instruction',
      'group': 'speech_auto',
      'help_text': 'Custom instruction for LLM (required when context_scope=CUSTOM)',
      'order': 5,
      'placeholder': 'Generate a brief message that...',
      'visible_when': 'enabled == true && mode == 'auto' && context_scope == 'custom'',
      'widget_type': 'textarea',
    },
    'include_tool_params': {
      'display_name': 'Include Tool Parameters',
      'group': 'speech_auto',
      'help_text': 'Include tool parameters in context for speech generation',
      'order': 6,
      'visible_when': 'enabled == true && mode == 'auto'',
      'widget_type': 'switch',
    },
    'include_user_intent': {
      'display_name': 'Include User Intent',
      'group': 'speech_auto',
      'help_text': 'Include detected user intent in context',
      'order': 7,
      'visible_when': 'enabled == true && mode == 'auto'',
      'widget_type': 'switch',
    },
    'max_tokens': {
      'display_name': 'Max Tokens',
      'group': 'speech_auto',
      'help_text': 'Maximum tokens for generated speech',
      'max_value': 200,
      'min_value': 10,
      'order': 8,
      'step': 1,
      'visible_when': 'enabled == true && mode == 'auto'',
      'widget_type': 'slider',
    },
    'temperature': {
      'display_name': 'Temperature',
      'group': 'speech_auto',
      'help_text': 'LLM temperature (higher = more creative)',
      'max_value': 2,
      'min_value': 0,
      'order': 9,
      'step': 0.1,
      'visible_when': 'enabled == true && mode == 'auto'',
      'widget_type': 'slider',
    },
    'speech_style': {
      'display_name': 'Speech Style',
      'group': 'speech_auto',
      'help_text': 'Style guidance for speech generation',
      'order': 10,
      'placeholder': 'friendly, professional, concise',
      'visible_when': 'enabled == true && mode == 'auto'',
      'widget_type': 'text',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class ExecutionConfigUISchema {
  static const String modelName = 'ExecutionConfig';

  static const Map<String, Map<String, dynamic>> fields = {
    'mode': {
      'display_name': 'Execution Mode',
      'group': 'execution',
      'help_text': 'Whether to wait for speech (sequential) or run in parallel',
      'options': [{"label": "Sequential (speech then execute)", "value": "sequential"}, {"label": "Parallel (speech and execute together)", "value": "parallel"}],
      'widget_type': 'dropdown',
    },
    'speech_timeout_ms': {
      'display_name': 'Speech Timeout (ms)',
      'group': 'execution',
      'help_text': 'Max time to wait for speech in sequential mode',
      'max_value': 10000,
      'min_value': 100,
      'order': 1,
      'step': 100,
      'visible_when': 'mode == 'sequential'',
      'widget_type': 'number',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class VariableAssignmentUISchema {
  static const String modelName = 'VariableAssignment';

  static const Map<String, Map<String, dynamic>> fields = {
    'target_variable': {
      'display_name': 'Target Variable',
      'group': 'assignment',
      'help_text': 'Name of the dynamic variable to update',
      'placeholder': 'guest_id',
      'widget_type': 'text',
    },
    'source_field': {
      'display_name': 'Source Field',
      'group': 'assignment',
      'help_text': 'Path to field in tool result (dot notation)',
      'order': 1,
      'placeholder': 'data.guest_id',
      'widget_type': 'text',
    },
    'operator': {
      'display_name': 'Operator',
      'group': 'assignment',
      'help_text': 'How to assign the value',
      'options': [{"label": "Set (always)", "value": "set"}, {"label": "Set if Exists", "value": "set_if_exists"}, {"label": "Set if Truthy", "value": "set_if_truthy"}, {"label": "Append to List", "value": "append"}, {"label": "Increment Number", "value": "increment"}, {"label": "Transform with Function", "value": "transform"}],
      'order': 2,
      'widget_type': 'dropdown',
    },
    'default_value': {
      'display_name': 'Default Value',
      'group': 'assignment',
      'help_text': 'Default value if source field not found',
      'order': 3,
      'placeholder': 'null',
      'widget_type': 'text',
    },
    'transform_expr': {
      'display_name': 'Transform Expression',
      'group': 'assignment',
      'help_text': 'Simple transformation expression (e.g., 'bool(value)', 'str(value)')',
      'order': 4,
      'placeholder': 'bool(value)',
      'visible_when': 'operator == 'transform'',
      'widget_type': 'text',
    },
    'transform_func': {
      'display_name': 'Transform Function',
      'help_text': 'Custom callable for complex transformations (set programmatically)',
      'widget_type': 'hidden',
    },
    'transform_execution': {
      'display_name': 'Transform Execution',
      'group': 'assignment',
      'help_text': 'Execution mode for transform_func',
      'options': [{"label": "Sync (block)", "value": "sync"}, {"label": "Async (fire-and-forget)", "value": "async"}, {"label": "Await (async but wait)", "value": "await"}],
      'order': 5,
      'visible_when': 'operator == 'transform'',
      'widget_type': 'dropdown',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class DynamicVariableConfigUISchema {
  static const String modelName = 'DynamicVariableConfig';

  static const Map<String, Map<String, dynamic>> fields = {
    'enabled': {
      'display_name': 'Enable Dynamic Variables',
      'group': 'dynamic_vars',
      'help_text': 'Update conversation/session variables based on tool results',
      'widget_type': 'switch',
    },
    'assignments': {
      'display_name': 'Variable Assignments',
      'group': 'dynamic_vars',
      'help_text': 'List of variable assignment rules',
      'item_label': 'Assignment {index}',
      'order': 1,
      'visible_when': 'enabled == true',
      'widget_type': 'array_editor',
    },
    'on_error': {
      'display_name': 'On Error',
      'group': 'dynamic_vars',
      'help_text': 'Behavior on assignment error',
      'options': [{"label": "Ignore", "value": "ignore"}, {"label": "Log Warning", "value": "log"}, {"label": "Raise Exception", "value": "raise"}],
      'order': 2,
      'visible_when': 'enabled == true',
      'widget_type': 'dropdown',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}
