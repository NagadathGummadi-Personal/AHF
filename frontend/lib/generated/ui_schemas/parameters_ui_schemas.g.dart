// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by scripts/generate_flutter.py

class ToolParameterUISchema {
  static const String modelName = 'ToolParameter';

  static const Map<String, Map<String, dynamic>> fields = {
    'name': {
      'display_name': 'Parameter Name',
      'group': 'basic',
      'help_text': 'Unique name for this parameter (snake_case recommended)',
      'placeholder': 'user_id',
      'widget_type': 'text',
    },
    'description': {
      'display_name': 'Description',
      'group': 'basic',
      'help_text': 'Description of the parameter (shown to LLM and users)',
      'order': 1,
      'placeholder': 'Describe what this parameter is for...',
      'widget_type': 'textarea',
    },
    'required': {
      'display_name': 'Required',
      'group': 'basic',
      'help_text': 'Whether this parameter must be provided',
      'order': 2,
      'widget_type': 'switch',
    },
    'default': {
      'display_name': 'Default Value',
      'group': 'basic',
      'help_text': 'Default value if parameter is not provided',
      'order': 3,
      'placeholder': 'null',
      'widget_type': 'text',
    },
    'deprecated': {
      'display_name': 'Deprecated',
      'group': 'advanced',
      'help_text': 'Mark this parameter as deprecated',
      'order': 10,
      'widget_type': 'switch',
    },
    'examples': {
      'display_name': 'Examples',
      'group': 'advanced',
      'help_text': 'Example values for this parameter',
      'item_label': 'Example {index}',
      'order': 11,
      'widget_type': 'array_editor',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class StringParameterUISchema {
  static const String modelName = 'StringParameter';

  static const Map<String, Map<String, dynamic>> fields = {
    'name': {
      'display_name': 'Parameter Name',
      'group': 'basic',
      'help_text': 'Unique name for this parameter (snake_case recommended)',
      'placeholder': 'user_id',
      'widget_type': 'text',
    },
    'description': {
      'display_name': 'Description',
      'group': 'basic',
      'help_text': 'Description of the parameter (shown to LLM and users)',
      'order': 1,
      'placeholder': 'Describe what this parameter is for...',
      'widget_type': 'textarea',
    },
    'required': {
      'display_name': 'Required',
      'group': 'basic',
      'help_text': 'Whether this parameter must be provided',
      'order': 2,
      'widget_type': 'switch',
    },
    'default': {
      'display_name': 'Default Value',
      'group': 'basic',
      'help_text': 'Default value if parameter is not provided',
      'order': 3,
      'placeholder': 'null',
      'widget_type': 'text',
    },
    'deprecated': {
      'display_name': 'Deprecated',
      'group': 'advanced',
      'help_text': 'Mark this parameter as deprecated',
      'order': 10,
      'widget_type': 'switch',
    },
    'examples': {
      'display_name': 'Examples',
      'group': 'advanced',
      'help_text': 'Example values for this parameter',
      'item_label': 'Example {index}',
      'order': 11,
      'widget_type': 'array_editor',
    },
    'param_type': {
      'display_name': 'Type',
      'widget_type': 'hidden',
    },
    'enum': {
      'display_name': 'Allowed Values (Enum)',
      'group': 'constraints',
      'help_text': 'If set, parameter must be one of these values',
      'item_label': 'Value {index}',
      'order': 4,
      'widget_type': 'array_editor',
    },
    'format': {
      'display_name': 'Format',
      'group': 'constraints',
      'help_text': 'Expected format for validation',
      'options': [{"label": "None", "value": ""}, {"label": "Email", "value": "email"}, {"label": "URI/URL", "value": "uri"}, {"label": "Date (YYYY-MM-DD)", "value": "date"}, {"label": "DateTime (ISO 8601)", "value": "date-time"}, {"label": "Time (HH:MM:SS)", "value": "time"}, {"label": "UUID", "value": "uuid"}, {"label": "Hostname", "value": "hostname"}, {"label": "IPv4 Address", "value": "ipv4"}, {"label": "IPv6 Address", "value": "ipv6"}],
      'order': 5,
      'widget_type': 'dropdown',
    },
    'min_length': {
      'display_name': 'Min Length',
      'group': 'constraints',
      'help_text': 'Minimum string length',
      'max_value': 10000,
      'min_value': 0,
      'order': 6,
      'widget_type': 'number',
    },
    'max_length': {
      'display_name': 'Max Length',
      'group': 'constraints',
      'help_text': 'Maximum string length',
      'max_value': 100000,
      'min_value': 1,
      'order': 7,
      'widget_type': 'number',
    },
    'pattern': {
      'display_name': 'Pattern (Regex)',
      'group': 'constraints',
      'help_text': 'Regular expression pattern for validation',
      'order': 8,
      'placeholder': '^[a-z]+$',
      'widget_type': 'text',
    },
    'coerce': {
      'display_name': 'Coerce to String',
      'group': 'advanced',
      'help_text': 'Automatically convert other types to string',
      'order': 12,
      'widget_type': 'switch',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class NumericParameterUISchema {
  static const String modelName = 'NumericParameter';

  static const Map<String, Map<String, dynamic>> fields = {
    'name': {
      'display_name': 'Parameter Name',
      'group': 'basic',
      'help_text': 'Unique name for this parameter (snake_case recommended)',
      'placeholder': 'user_id',
      'widget_type': 'text',
    },
    'description': {
      'display_name': 'Description',
      'group': 'basic',
      'help_text': 'Description of the parameter (shown to LLM and users)',
      'order': 1,
      'placeholder': 'Describe what this parameter is for...',
      'widget_type': 'textarea',
    },
    'required': {
      'display_name': 'Required',
      'group': 'basic',
      'help_text': 'Whether this parameter must be provided',
      'order': 2,
      'widget_type': 'switch',
    },
    'default': {
      'display_name': 'Default Value',
      'group': 'basic',
      'help_text': 'Default value if parameter is not provided',
      'order': 3,
      'placeholder': 'null',
      'widget_type': 'text',
    },
    'deprecated': {
      'display_name': 'Deprecated',
      'group': 'advanced',
      'help_text': 'Mark this parameter as deprecated',
      'order': 10,
      'widget_type': 'switch',
    },
    'examples': {
      'display_name': 'Examples',
      'group': 'advanced',
      'help_text': 'Example values for this parameter',
      'item_label': 'Example {index}',
      'order': 11,
      'widget_type': 'array_editor',
    },
    'param_type': {
      'display_name': 'Type',
      'widget_type': 'hidden',
    },
    'min': {
      'display_name': 'Minimum Value',
      'group': 'constraints',
      'help_text': 'Minimum allowed value (inclusive)',
      'order': 4,
      'widget_type': 'number',
    },
    'max': {
      'display_name': 'Maximum Value',
      'group': 'constraints',
      'help_text': 'Maximum allowed value (inclusive)',
      'order': 5,
      'widget_type': 'number',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class IntegerParameterUISchema {
  static const String modelName = 'IntegerParameter';

  static const Map<String, Map<String, dynamic>> fields = {
    'name': {
      'display_name': 'Parameter Name',
      'group': 'basic',
      'help_text': 'Unique name for this parameter (snake_case recommended)',
      'placeholder': 'user_id',
      'widget_type': 'text',
    },
    'description': {
      'display_name': 'Description',
      'group': 'basic',
      'help_text': 'Description of the parameter (shown to LLM and users)',
      'order': 1,
      'placeholder': 'Describe what this parameter is for...',
      'widget_type': 'textarea',
    },
    'required': {
      'display_name': 'Required',
      'group': 'basic',
      'help_text': 'Whether this parameter must be provided',
      'order': 2,
      'widget_type': 'switch',
    },
    'default': {
      'display_name': 'Default Value',
      'group': 'basic',
      'help_text': 'Default value if parameter is not provided',
      'order': 3,
      'placeholder': 'null',
      'widget_type': 'text',
    },
    'deprecated': {
      'display_name': 'Deprecated',
      'group': 'advanced',
      'help_text': 'Mark this parameter as deprecated',
      'order': 10,
      'widget_type': 'switch',
    },
    'examples': {
      'display_name': 'Examples',
      'group': 'advanced',
      'help_text': 'Example values for this parameter',
      'item_label': 'Example {index}',
      'order': 11,
      'widget_type': 'array_editor',
    },
    'param_type': {
      'display_name': 'Type',
      'widget_type': 'hidden',
    },
    'min': {
      'display_name': 'Minimum Value',
      'group': 'constraints',
      'help_text': 'Minimum allowed value (inclusive)',
      'order': 4,
      'widget_type': 'number',
    },
    'max': {
      'display_name': 'Maximum Value',
      'group': 'constraints',
      'help_text': 'Maximum allowed value (inclusive)',
      'order': 5,
      'widget_type': 'number',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class BooleanParameterUISchema {
  static const String modelName = 'BooleanParameter';

  static const Map<String, Map<String, dynamic>> fields = {
    'name': {
      'display_name': 'Parameter Name',
      'group': 'basic',
      'help_text': 'Unique name for this parameter (snake_case recommended)',
      'placeholder': 'user_id',
      'widget_type': 'text',
    },
    'description': {
      'display_name': 'Description',
      'group': 'basic',
      'help_text': 'Description of the parameter (shown to LLM and users)',
      'order': 1,
      'placeholder': 'Describe what this parameter is for...',
      'widget_type': 'textarea',
    },
    'required': {
      'display_name': 'Required',
      'group': 'basic',
      'help_text': 'Whether this parameter must be provided',
      'order': 2,
      'widget_type': 'switch',
    },
    'default': {
      'display_name': 'Default Value',
      'group': 'basic',
      'help_text': 'Default value if parameter is not provided',
      'order': 3,
      'placeholder': 'null',
      'widget_type': 'text',
    },
    'deprecated': {
      'display_name': 'Deprecated',
      'group': 'advanced',
      'help_text': 'Mark this parameter as deprecated',
      'order': 10,
      'widget_type': 'switch',
    },
    'examples': {
      'display_name': 'Examples',
      'group': 'advanced',
      'help_text': 'Example values for this parameter',
      'item_label': 'Example {index}',
      'order': 11,
      'widget_type': 'array_editor',
    },
    'param_type': {
      'display_name': 'Type',
      'widget_type': 'hidden',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class ArrayParameterUISchema {
  static const String modelName = 'ArrayParameter';

  static const Map<String, Map<String, dynamic>> fields = {
    'name': {
      'display_name': 'Parameter Name',
      'group': 'basic',
      'help_text': 'Unique name for this parameter (snake_case recommended)',
      'placeholder': 'user_id',
      'widget_type': 'text',
    },
    'description': {
      'display_name': 'Description',
      'group': 'basic',
      'help_text': 'Description of the parameter (shown to LLM and users)',
      'order': 1,
      'placeholder': 'Describe what this parameter is for...',
      'widget_type': 'textarea',
    },
    'required': {
      'display_name': 'Required',
      'group': 'basic',
      'help_text': 'Whether this parameter must be provided',
      'order': 2,
      'widget_type': 'switch',
    },
    'default': {
      'display_name': 'Default Value',
      'group': 'basic',
      'help_text': 'Default value if parameter is not provided',
      'order': 3,
      'placeholder': 'null',
      'widget_type': 'text',
    },
    'deprecated': {
      'display_name': 'Deprecated',
      'group': 'advanced',
      'help_text': 'Mark this parameter as deprecated',
      'order': 10,
      'widget_type': 'switch',
    },
    'examples': {
      'display_name': 'Examples',
      'group': 'advanced',
      'help_text': 'Example values for this parameter',
      'item_label': 'Example {index}',
      'order': 11,
      'widget_type': 'array_editor',
    },
    'param_type': {
      'display_name': 'Type',
      'widget_type': 'hidden',
    },
    'items': {
      'display_name': 'Item Type',
      'group': 'constraints',
      'help_text': 'Schema for array items',
      'order': 4,
      'widget_type': 'object_editor',
    },
    'min_items': {
      'display_name': 'Min Items',
      'group': 'constraints',
      'help_text': 'Minimum number of items',
      'max_value': 1000,
      'min_value': 0,
      'order': 5,
      'widget_type': 'number',
    },
    'max_items': {
      'display_name': 'Max Items',
      'group': 'constraints',
      'help_text': 'Maximum number of items',
      'max_value': 10000,
      'min_value': 1,
      'order': 6,
      'widget_type': 'number',
    },
    'unique_items': {
      'display_name': 'Unique Items',
      'group': 'constraints',
      'help_text': 'Whether items must be unique',
      'order': 7,
      'widget_type': 'switch',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}

class ObjectParameterUISchema {
  static const String modelName = 'ObjectParameter';

  static const Map<String, Map<String, dynamic>> fields = {
    'name': {
      'display_name': 'Parameter Name',
      'group': 'basic',
      'help_text': 'Unique name for this parameter (snake_case recommended)',
      'placeholder': 'user_id',
      'widget_type': 'text',
    },
    'description': {
      'display_name': 'Description',
      'group': 'basic',
      'help_text': 'Description of the parameter (shown to LLM and users)',
      'order': 1,
      'placeholder': 'Describe what this parameter is for...',
      'widget_type': 'textarea',
    },
    'required': {
      'display_name': 'Required',
      'group': 'basic',
      'help_text': 'Whether this parameter must be provided',
      'order': 2,
      'widget_type': 'switch',
    },
    'default': {
      'display_name': 'Default Value',
      'group': 'basic',
      'help_text': 'Default value if parameter is not provided',
      'order': 3,
      'placeholder': 'null',
      'widget_type': 'text',
    },
    'deprecated': {
      'display_name': 'Deprecated',
      'group': 'advanced',
      'help_text': 'Mark this parameter as deprecated',
      'order': 10,
      'widget_type': 'switch',
    },
    'examples': {
      'display_name': 'Examples',
      'group': 'advanced',
      'help_text': 'Example values for this parameter',
      'item_label': 'Example {index}',
      'order': 11,
      'widget_type': 'array_editor',
    },
    'param_type': {
      'display_name': 'Type',
      'widget_type': 'hidden',
    },
    'properties': {
      'display_name': 'Properties',
      'group': 'constraints',
      'help_text': 'Nested property definitions',
      'order': 4,
      'widget_type': 'object_editor',
    },
    'oneOf': {
      'display_name': 'One Of (Union Types)',
      'group': 'constraints',
      'help_text': 'Value must match one of these schemas',
      'item_label': 'Option {index}',
      'order': 5,
      'widget_type': 'array_editor',
    },
  };

  static Map<String, dynamic>? getFieldUI(String fieldName) {
    return fields[fieldName];
  }

  static String? getDisplayName(String fieldName) {
    return fields[fieldName]?['display_name'] as String?;
  }

  static String? getWidgetType(String fieldName) {
    return fields[fieldName]?['widget_type'] as String?;
  }

  static String? getGroup(String fieldName) {
    return fields[fieldName]?['group'] as String?;
  }

  static bool isVisible(String fieldName, Map<String, dynamic> formData) {
    final visibleWhen = fields[fieldName]?['visible_when'] as String?;
    if (visibleWhen == null) return true;
    return evaluateCondition(visibleWhen, formData);
  }

  static bool evaluateCondition(String condition, Map<String, dynamic> data) {
    // Simple condition evaluator
    // Supports: field == value, field != value, field == true/false
    // And compound conditions with &&
    final parts = condition.split('&&').map((p) => p.trim()).toList();
    for (final part in parts) {
      if (!_evaluateSingleCondition(part, data)) return false;
    }
    return true;
  }

  static bool _evaluateSingleCondition(String condition, Map<String, dynamic> data) {
    // Parse condition like 'enabled == true' or 'mode == \'auto\''
    final eqMatch = RegExp(r"(\w+)\s*==\s*(.+)").firstMatch(condition);
    if (eqMatch != null) {
      final field = eqMatch.group(1)!;
      var value = eqMatch.group(2)!.trim();
      // Remove quotes
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue == true;
      if (value == 'false') return fieldValue == false;
      return fieldValue?.toString() == value;
    }
    final neqMatch = RegExp(r"(\w+)\s*!=\s*(.+)").firstMatch(condition);
    if (neqMatch != null) {
      final field = neqMatch.group(1)!;
      var value = neqMatch.group(2)!.trim();
      if (value.startsWith("'") && value.endsWith("'")) {
        value = value.substring(1, value.length - 1);
      }
      final fieldValue = data[field];
      if (value == 'true') return fieldValue != true;
      if (value == 'false') return fieldValue != false;
      return fieldValue?.toString() != value;
    }
    return true;
  }

  /// Get fields grouped by their 'group' property
  static Map<String, List<String>> getGroupedFields() {
    final groups = <String, List<String>>{};
    for (final entry in fields.entries) {
      final group = entry.value['group'] as String? ?? 'default';
      groups.putIfAbsent(group, () => []).add(entry.key);
    }
    // Sort fields within each group by order
    for (final group in groups.keys) {
      groups[group]!.sort((a, b) {
        final orderA = fields[a]?['order'] as int? ?? 0;
        final orderB = fields[b]?['order'] as int? ?? 0;
        return orderA.compareTo(orderB);
      });
    }
    return groups;
  }
}
